;;; -*- Mode:Common-lisp; Package: TV; Base: 10.; Fonts: CPTFONT,HL12B,HL12BI -*-

;;;                           RESTRICTED RIGHTS LEGEND

;;;Use, duplication, or disclosure by the Government is subject to
;;;restrictions as set forth in subdivision (c)(1)(ii) of the Rights in
;;;Technical Data and Computer Software clause at 52.227-7013.
;;;
;;;                     TEXAS INSTRUMENTS INCORPORATED.
;;;                              P.O. BOX 2909
;;;                           AUSTIN, TEXAS 78769
;;;                                 MS 2151
;;;
;;; Copyright (C) 1983-1989 Texas Instruments Incorporated. All rights reserved.
;;;	** (c) Copyright 1980 Massachusetts Institute of Technology **
;;;
;;; Change history:
;;;
;;;  Date      Author	Description
;;; -------------------------------------------------------------------------------------
;;;  05/02/89 MAY  Changed *initial-who-line-screen-display-type* from :monochrome to :both.
;;;  04/10/89 MAY  Moved PREVIOUSLY-SELECTED-WINDOWS here from baswin.lisp and added doc string.
;;;  03/27/89 MAY  Changed continuous-repeat-delay to 1 - speeds up cursor movement in editor
;;;                   when lisp listener is busy scrolling output to screen.
;;;  01/27/89 KJF   [may] Added with-screens-previously-selected-windows for Multiple Monitor support (MMON).
;;;  01/27/89 KJF   [may] Some variables added for Multiple Monitor support (MMON system).  Searching for date
;;;                    will locate these. ( 08/15/88 KJF )
;;;  09/01/88 MAY  Moved defun of mouse-wakeup here. Dummy function below caused tv:sheet-expose
;;;                   (:method tv:sheet-expose) and (:method tv:select-mixin :select) to have disassembled code
;;;                   that did NOT contain "(mouse-wakeup)" during build process. Only code compiled after the defun
;;;                   of mouse-wakeup had the correct definition.
;;;  07/18/88 KJF   Fix in with-mouse-grabbed-internal to also check for mouse-process being bound
;;;                    during window system build.
;;;  07/11/88 KJF   Fix to DRAW-CHAR-INTERNAL to not do prepare-color if WINDOW arg is an array.  Fixes
;;;                    SPR #8202.
;;; 06/28/88  BJ   Added MX queue limiting code to prepare-sheet.
;;;  05/23/88  KJF     Renamed screen-descriptor instance variable of screen flavor to screens-who-line-screen
;;;                       since a source build is being done.
;;;  04/23/88  CJJ, PMH, KJF  Changes for multiple screen support.  Search for CJJ.
;;;  04/23/88  KJF      Changes for multiple screen support.  Search for KJF or date - 04/23/88.  Changes:
;;;                        -> COLOR-SHEET-P macro added
;;;                        -> Many new globals added.
;;;  04/10/88  KJF      Simple change to get-display-type function.  Also change to sheet-load-registers.
;;;  02/22/88  KJF       Changed one of the instance variables reserved for multiple screen/dual monitor
;;;                        support to screens-previously-selected-windows.
;;;  02/21/88 KJF       2 changes. 1) Default *default-...-color* values to color defaults instead of B&W.
;;;                        2) modified prepare-sheet to now use sheet-load-registers directly.
;;; 02/12/88  KJF      Moved get-display-type and color-system-p before sheet-load-registers.
;;;                    The color-system-p macro must be defined before trying to compile
;;;                     sheet-load-registers.
;;;  02/10/88  KJF       Changes for dual monitor and multiple screen support.  Search for KJF.
;;;  02/03/88 KJF        Renamed 2 :unused-reserved instance variables of SCREEN in anticipation of needing
;;;                         them for the dual monitor work.
;;;   9/15/87  PMH       Added *COLOR-MAPS* variable; this will be a list of all loaded color maps
;;;   9/11/87  PMH       Added PROCLAIMs for CVV-GET-COLOR and SELECT-COLOR-WITH-MOUSE functions
;;;   8/24/87  KWW      Final Changes based on code reading. This is the baseline submitted to Austin.
;;;                           1. Defined sheet flavor to have new instance variables in same locations as
;;;                              "unused" instance variables generated by the cloudy crystal ball in Dec 1986.
;;;                           2. Renamed unused instance variables to UNUSED-RESERVED-XX
;;;                           3. Removed save-array instance variable from blinker flavor
;;;                           4. Added unwind-protect to appropriate macros
;;;                           5. changed sheet-load-registers to call functions rather than send messages
;;;                           6. Reversed the order of the gray scale at the beginning of the color table
;;;                       7. moved blinker offset to blinker flavor
;;;   7/14/87  KWW      Added plane mask instance variable to sheet
;;;   7/14/87  KWW      Changed order of several system colors to give better mouse appearance
;;;   7/14/87  KWW      Changed default foreground and background to be set up for B&W rather than color
;;;                             Also defined a function for changing the defaults to color
;;;   5/29/87  KWW      Added color definitions
;;;   5/20/87  KWW      Modified prepare-sheet for color (load some registers) and xxx-gray ==> xxx-dense
;;;                         Since the gray arrays are now simple textures. Changes are marked with >>>
;;;   7/7/87    PMH       Modified the SHEET flavor to accept the :size option
;;;   4/24/87  TWE	Added a :DEALLOCATOR form for defwindow-resource to have it call the function
;;;			CLEAN-OUT-IO-BUFFER when a window instance gets to returned to its resource.
;;;   4/06/87  GRH	Added new draw-char-internal function to support changes in draw-string-internal.
;;;   4/02/87  GRH	Proclaim round-up-to-32 inline.
;;;   3/30/87  GRH	Improved documentation of %draw-character.
;;;   3/23/87  GRH	Fix %draw-char so that it is more equivalent to the old %draw-char, and also make it
;;;			not obsolete any more since it's functionality is still useful and distinct from %draw-character.
;;;   3/23/87  GRH	Fix draw-end-point bug in %draw-line, and removed some Elroy conditionals.
;;;   3/23/87  TWE	Changed the value of MOUSE-HANDEDNESS to be a symbol in the keyword package
;;;			to get around TV/W package problems.  This should have been done in the first place.
;;;   3/12/87  GRH	Defined new round-up-to-32 utility function used in fix for creating bit arrays.
;;;   3/12/87  GRH	Proclaimed font-object-p to be inline to speed up primitive draw-char.
;;;   3/06/87  TWE	Defined the defsubst CHAR-CMSH-BITS as per Patrick Dussud's recommentation.  This
;;;			is just like CHAR-BITS except that it only gets the control, meta, super and hyper bits
;;;			and not the mouse or keypad bits.
;;;  1/22/87    LGO 	Added *deselected-process-priority*
;;;  1/07/87    KDB	Added a MENU-PERMANENT flag DEFINE-SHEET-FLAGS to allow communication of
;;;                         value of :PERMANENT  in methods of W:MENU.
;;;  1/05/87   TWE	Changed the low-level macro redirect-array to not do any consing and to ignore its
;;;			element-type argument which wasn't really used.  Changed defwindow-resource
;;;			to use the common-lisp compile form instead of the obsolete mac-lisp style.  Changed
;;;			uses of integerp to use the fixnum type for performance reasons.
;;; 12/22/86   TWE	Made several changes to make the build process cleaner.
;;;			Moved the DEFVARs for MOUSE-BLINKER, MOUSE-HANDEDNESS, MOUSE-PROCESS and
;;;			MOUSE-CURSOR-CLOSED-STATE from MOUSE to here.
;;;			Moved the DEFVARs for KBD-TYI-HOOK INITIAL-REPEAT-DELAY, CONTINUOUS-REPEAT-DELAY,
;;;			and PROCESS-IS-IN-ERROR from BASSTR to here.  Moved the following from SHEET
;;;			to here: SHEET-ME-OR-MY-KID-P, SHEET-CAN-GET-LOCK and SHEET-CAN-GET-LOCK-INTERNAL.
;;; 12/01/86   TWE	Added the init option :keypad-enable to SHEET for keypad support.
;;; 11/26/86   TWE	Changed SHIFT-INTO-TEXT/GRAPHICS-MODE functions to use their argument to placate
;;;			the compiler.
;;; 11/25/86   TWE	Added hooks for color support.
;;; 11/21/86   GRH	Added the new With-clipping-rectangle macro to be used to implement clipping.
;;; 11/17/86   TWE	Changed *screen-standard-font-map* and *window-standard-font-map* to not evaluate
;;;			all of their fonts.
;;; 11/03/86   LGO 	Added *selected-process-priority*
;;; 11/03/86   TWE	Moved the gray constant stuff from SCRMAN to here.
;;; 10/29/86   TWE	Removed references to the V2 package, which is where %DRAW-SHADED-TRIANGLE
;;;			and friends used to be located.  They are now in the system package.
;;; 10/10/86   TWE	Moved the global variable *DEFAULT-READ-WHOSTATE* from BASSTR to here so that
;;;			other functions can use this when waiting on the keyboard and display the same
;;;			string as the who-state.
;;; 09/16/86   TWE	Added keypad-enable to the list of flags in sheet.  This is part of the support for the
;;;			keypad characters.
;;; 09/10/86   TWE	Added `eval' into the `eval-when' list for %DRAW-SHADED-TRIANGLE.
;;; 08/20/86   TWE	Removed the dummy definition of compiler:make-obsolete.1
;;; 08/08/86   TWE	Hacked %draw-char to get around a microcode bug relating to drawing characters in
;;;			a variable width font.
;;; 08/07/86   TWE	Fixed the defstruct for FONT to specify the :array-leader inside of a (:type ...) clause
;;;			instead of being a clause by itself.
;;; 08/06/86   GRH	Put in support for obsolete drawing primitives.  Done by TWE.
;;; 08/04/86   TWE	Removed the defvars for MOUSE-X and MOUSE-Y since they were defined in the GLOBAL
;;;			package (now SYS).  These symbols were moved to DEFINE-TV-PACKAGE so that they
;;;			become present in the TV and W packages.
;;; 08/04/86   TWE	Define a function FONT-OBJECT-P to localize type checks for fonts.
;;; 08/04/86   TWE	Removed the empty DEFUN for the BEEP function so that the definition in the SOUND
;;;			file will not get a warning message about redefinition.
;;; 07/29/86   TWE	Changed to use Common Lisp functions.
;;; 07/29/86   TWE	Changed CLOCK-TYPE to be :12-HOUR instead of '12-HOUR.
;;; 07/21/86   TWE	Defined a SAFE-CHAR= function to correct a notification problem.  The notification code
;;;			was inserting a :DEEXPOSE into the keyboard buffer.  A test of CHAR= was being done
;;;			on that which went into the error handler, since :DEEXPOSE is not a character object.
;;; 06/18/86   TWE	Changed REDIRECT-ARRAY to use ADJUST-ARRAY instead of SI:CHANGE-INDIRECT-ARRAY.
;;; 06/06/86   TWE	Added a hack to make the COMPILER:MAKE-OBSOLETE-1 function defined in the
;;;			cold load environment.
;;; 04/24/86   TWE	Changed the flags to add new ones for menus.
;;; 04/08/86   TWE	Defined *SCREEN-STANDARD-FONT-MAP* to be used for screens as a default font map.
;;; 04/08/86   LGO	Added DELAYING-COMPUTE-GEOMETRY macro.
;;; 03/04/86   LGO	Moved FLASH-DURATION to WINDOW;SOUND, and deleted *BEEP-ALIST*

(DEFVAR CLOCK-TYPE :12-HOUR
  "The type of clock <12Hr. -vs- 24Hr.> that the user would
 like to have in the Status Line.")
(DEFVAR DEFAULT-NUMBER-OF-WHO-LINE-DOCUMENTATION-LINES 2.
  "Initial value for the number of who line documentation lines.")
(DEFVAR WHO-LINE-VSP 3.
  "Number of pixels to space between each line in the Who Line window.")
(DEFVAR *OVERLAP-SPLIT-SCREEN* NIL
  "Allows the user to create an overlapping split screen configuration")

(DEFVAR DEFAULT-SCREEN NIL
  "This is the screen on which windows are created by default.")
(DEFVAR ALL-THE-SCREENS NIL
  "List of all screen objects.")
;; may 04/25/89
;; Now that we have multiple screens, main-screen is NOT necessarily the "main"
;; screen. It is set to *initial-screen* in tv:initialize at boot time.
;; The reasons (now obscure) for having *initial-screen* instead of just using
;; main-screen are no longer valid after REL 6. Use w:default-screen instead.
(DEFVAR MAIN-SCREEN NIL
  "This is the screen-object for the main display, not counting the who-line.
  In a monochrome system it is a 1 bit object, in color, an 8 bit object.")
(DEFVAR WHO-LINE-SCREEN NIL
  "This is the screen-object for the who-line area.
  The parts of the who-line are inferiors of this screen.")

(DEFVAR WHO-LINE-RUN-STATE-SHEET NIL
  "This is the window, part of the who-line, on which RUN, etc., appears.")
(DEFVAR WHO-LINE-FILE-STATE-SHEET NIL
  "This is the window, part of the who-line, on which the file being read appears.")
(DEFVAR NWATCH-WHO-LINE-SHEET NIL
  "This is the window, part of the who-line, on which the current time appears.")
(DEFVAR USER-ID-WHO-LINE-SHEET NIL
  "This is the window, part of the who-line, on which the user-id appears.")
(DEFVAR CURRENT-PACKAGE-WHO-LINE-SHEET NIL
  "This is the window, part of the who-line, on which the current package appears.")
(DEFVAR WHO-LINE-DOCUMENTATION-WINDOW NIL
  "This is the window, part of the who-line, for the
  mouse-documentation line.")
(DEFVAR WHO-LINE-MOUSE-GRABBED-DOCUMENTATION NIL
  "If non-NIL, this overrides all other sources of mouse documentation
  for the who-line.")

;;; Standard Font & Messages Definitions

;;; Naming Conventions
;;; *foo-STANDARD-MESSAGE* - a string to announce the occurence of FOO
;;;                       or to label the display of FOO.
;;; *foo-STANDARD-FONT* - the font to use to display *foo-STANDARD-MESSAGE*
;;; *foo-STANDARD-BEEP* - the beep type to announce the display of
;;;                       *foo-STANDARD-MESSAGE*
;;;                       :SILENT   - no flash, no sound
;;;                       :DEFAULT  - whatever the BEEP function defines
;;;                                   as default (currently flash, no sound)
;;;                       NIL       - same as :DEFAULT
;;;                       other     - a keyword identifying an entry in the
;;;                                   BEEP sound list (equivalent to :DEFAULT
;;;                                   if the keyword is not in the list)

(DEFVAR *DEFAULT-FONT* FONTS:CPTFONT)

;;; The font-alists of actual screens are built using this as a pattern.
;;; There is a SCREEN :AFTER :INIT method which uses this constant to
;;; create symbols which can be used as fonts.
(DEFPARAMETER DEFAULT-FONT-ALIST
              '((:DEFAULT       . *DEFAULT-FONT*)
		(:LABEL         . FONTS:CPTFONT)
		(:MENU          . FONTS:MEDFNT)
		(:MENU-STANDOUT . FONTS:HL12B)
		(:MARGIN-CHOICE . FONTS:CPTFONT))
              "This is a pattern for creating the FONT-ALIST variables of screens.
It maps standard FONT PURPOSES into names of fonts.")

;;; We have a standard font map for screens which is different from
;;; *window-standard-font-map* because we want the window version to
;;; contain the font purpose :DEFAULT to take advantage of the font
;;; purpose mechanism.  This doesn't work well with screens because they
;;; have a timing problem with font purposes.
(DEFVAR *SCREEN-STANDARD-FONT-MAP* `(,*DEFAULT-FONT* FONTS:TR8B FONTS:TR8B)
  "Standard font-map list for screens.")

;;;; General Windows
(DEFVAR *WINDOW-STANDARD-FONT-MAP*
        '(:default FONTS:tr8B FONTS:tr8B) ;;Changed *DEFAULT-FONT* to :default WS 2.1 -dlc
;changed hl10 to tr8 to fix the zero-line editor problem when using the zwei:pop-up-edtring function -- GSM for TWE 22 Nov 85
  "Standard font-map list for windows.  The first font in the list is for
normal input/output.  The second font is used for extra emphasis.  In
ZMACS this would be used to highlight important comments.  The third
font is used to specially flag some text.  In ZMACS this would be used
to highlight documentation strings.")

(DEFVAR *FRAME-LABEL-STANDARD-FONT* *DEFAULT-FONT*
  "Standard font for labeling the main program window such as Inspector,
Lisp Listener, Peek, etc.")

(DEFVAR *WINDOW-PANE-LABEL-STANDARD-FONT* *DEFAULT-FONT*
  "Standard font for labeling a pane within a constraint frame or
program window.")

(DEFPARAMETER *microcode-mouse-cursor-buffer-height* 32.
  "Height of the microcode buffer that holds a copy of the mouse cursor pattern.")

(DEFPARAMETER *microcode-mouse-cursor-buffer-width* 32.
  "Width of the microcode buffer that holds a copy of the mouse cursor pattern.")

(DEFVAR *MOUSE-DOCUMENTATION-LINE-STANDARD-FONT* FONTS:HL12B
  "Standard font for documentation in the mouse documentation line.
This will only be noticed after a system build is done.")

(DEFVAR *MOUSE-DOCUMENTATION-LINE-BUTTONS-STANDARD-FONT* FONTS:HL12BI
  "Standard font for the mouse button indicators in the mouse
documentation line.  This will only be noticed after a system build
is done.")

(DEFVAR *STATUS-LINE-STANDARD-FONT* *DEFAULT-FONT*
  "Standard font for information put into the windows of the status
line.  This will only be noticed after a system build is done.")

(DEFVAR *MENU-ITEM-STANDARD-FONT* *DEFAULT-FONT*
  "Standard font for menu items in multiple values menus.")


;;;; More Processing & Scrolling
(DEFVAR *MORE-PROCESSING-STANDARD-FONT* *DEFAULT-FONT*
  "Standard font for all messages related to more processing.")

(DEFVAR *MORE-PROCESSING-STANDARD-BEEP* :SILENT
  "Standard beep type keyword for
*UNIDIRECTIONAL-MORE-STANDARD-MESSAGE* string.")

(DEFVAR *UNIDIRECTIONAL-MORE-STANDARD-MESSAGE* "**MORE**"
  "Standard message string indicating that forward-only More processing
is available [compare with *BIDIRECTIONAL-MORE-STANDARD-MESSAGE*].")

(DEFVAR *BIDIRECTIONAL-MORE-STANDARD-MESSAGE* "--MORE--"
  "Standard message string indicating that forward and backward More
processing is available [compare with
*UNIDIRECTIONAL-MORE-STANDARD-MESSAGE*].")

(DEFVAR *MORE-FORWARD-STANDARD-MESSAGE* "More Below"
  "Standard message string indicating that there is more text to be seen
by scrolling forward.")

(DEFVAR *NO-MORE-FORWARD-STANDARD-MESSAGE* "Bottom"
  "Standard message string indicating that there is NO more text to be
seen by scrolling forward.")

(DEFVAR *MORE-BACKWARD-STANDARD-MESSAGE* "More Above"
  "Standard message string indicating that there is more text to be seen
by scrolling backward.")

(DEFVAR *NO-MORE-BACKWARD-STANDARD-MESSAGE* "Top"
  "Standard message string indicating that there is NO more text to be
seen by scrolling backward.")

;;;; Choose Variable Value Menu fonts.
(DEFVAR *CHOOSE-VARIABLE-VALUES-NAME-STANDARD-FONT* *DEFAULT-FONT*
  "Standard font for variable names (:name-font init option) in Choose
Variable Values Menus.")

(DEFVAR *CHOOSE-VARIABLE-VALUES-VALUE-STANDARD-FONT* *DEFAULT-FONT*
  "Standard font for variable values (:value-font init option) in Choose
Variable Values Menus.")

(DEFVAR *CHOOSE-VARIABLE-VALUES-STRING-STANDARD-FONT* *DEFAULT-FONT*
  "Standard font for title strings (:string-font init option) and margin
choice labels in Choose Variable Values Menus.")

(DEFVAR *CHOOSE-VARIABLE-VALUES-UNSELECTED-CHOICE-STANDARD-FONT* FONTS:HL10
  "Standard font for unselected variable values (:unselected-choice-font
init option) in Choose Variable Values Menus.")

(DEFVAR *CHOOSE-VARIABLE-VALUES-SELECTED-STANDARD-FONT* FONTS:HL10B
  "Standard font for selected variable values (:selected-choice-font
init option) in Choose Variable Values Menus.")


;;; Miscellaneous


(DEFVAR *REMOVE-TYPEOUT-STANDARD-MESSAGE*
	      "Press the space bar to remove this message."
  "Standard message string telling user how to get rid of a temporary
typeout window.")

(DEFVAR *REMOVE-TYPEOUT-STANDARD-FONT* *DEFAULT-FONT*
  "Standard font for *REMOVE-TYPEOUT-STANDARD-MESSAGE* string.")

(DEFVAR *REMOVE-TYPEOUT-STANDARD-BEEP* :SILENT
  "Standard beep type keyword for
*REMOVE-TYPEOUT-STANDARD-MESSAGE* string.")


(DEFVAR *set-mouse-to-selected-screen* nil
  "If non-nil, the mouse will always move to the same screen as the
selected window.")

;;; CJJ 04/22/88.  These next 8 added for multiple screen support.
(DEFVAR *screens-exposed-at-disk-save* nil)

(DEFCONSTANT si:%CSIB-color-presence-test-result-byte-offset #xC801C7)

(DEFCONSTANT si:%%NuBus-slot-relative-bits (BYTE 24 0))

(DEFCONSTANT *SIB-board-type* "SIB")

(DEFVAR *ok-to-expose-color-screens-when-color-presence-test-failed* nil)

(DEFPARAMETER *initial-who-line-screen-bits-per-pixel* 1.)

(DEFPARAMETER *initial-who-line-screen-display-type* :both) ; may 05/02/89 :monochrome)

(DEFVAR *initial-screen* nil
  "The first screen exposed at boot-up.  The value of this variable may be changed at boot-up.
If the value at boot-up does not pass ACCEPTABLE-INITIAL-SCREEN-P, then another screen may
be found or created which passes the test.")

;; These 10 created by CJJ for Multiple Monitor (MMON) support.  08/15/88 KJF. ;; may 01/27/89
(DEFVAR *unglitched-mouse-x* 0.
  "Set by MOUSE-INPUT.
Used by MAYBE-CHANGE-MOUSE-SHEET to determine if and how much mouse moved off mouse sheet.")

(DEFVAR *unglitched-mouse-y* 0.
  "Set by MOUSE-INPUT.
Used by MAYBE-CHANGE-MOUSE-SHEET to determine if and how much mouse moved off mouse sheet.")

(DEFVAR *unglitched-mouse-x-speed* 0.
  "Set by MOUSE-INPUT.
Used by MAYBE-CHANGE-MOUSE-SHEET to determine how fast mouse tried to move off mouse sheet.")

(DEFVAR *unglitched-mouse-y-speed* 0.
  "Set by MOUSE-INPUT.
Used by MAYBE-CHANGE-MOUSE-SHEET to determine how fast mouse tried to move off mouse sheet.")

(DEFPARAMETER *previous-unglitched-mouse-x* 0)

(DEFPARAMETER *previous-unglitched-mouse-y* 0)

(DEFPARAMETER *transport-mouse-along-trajectory* t
  "Controls paradigm for mouse transport.
When non-NIL, the mouse is transported along a trajectory from the current
unglitched mouse point in a line which intersects the previous mouse point.
This allows the mouse to jump over areas which do not handle the mouse.
When NIL, the mouse is transported to the current unglitched mouse point,
if that point is in an area which handles the mouse.")

(DEFVAR *all-the-monitor-controllers* nil
  "An array of monitor-controller instances.  It has a fill-pointer.
Contains one instance for each monitor-controller attached to this system.
Element zero contains the primary monitor-controller instance
for the monitor-controller which has a keyboard attached.
These instances are rebuilt dynamically at boot time by INITIALIZE-MONITOR-CONTROLLERS.
Do not retain a pointer to one of these instances, instead retain an index into this array.")

(DEFVAR *all-the-monitors* nil
  "A list of all the CONFIGURED monitors.  This list is rebuild dynamically at boot time.")

(DEFVAR *unconfigured-monitors* nil
  "A list of all monitors supported by the monitor-controllers attached to this hardware,
which are not configured.  That is, screens cannot be exposed on them and the mouse cannot move onto them.
This list is rebuild dynamically at boot time.")

;;;
;;; This is a total kludge to prevent the following DEFVAR from getting an invalid compiler warning.  (see COMPILER:SPECIAL-1)
;;;
;;;(EVAL-WHEN (compile) (SETF (GET 'BEEP 'SPECIAL) 'COMPILER::INIT-SYSTEM-VAR-PROPERTIES)) ;; commented out by TWE 5/26/86
(DEFVAR BEEP T
  "Controls the basic interpretation of beeping with the function BEEP.
Values are: T, :FLASH, :BEEP, and NIL.  Refer to function BEEP.")

;;;These are here because they are needed in more than one file.
(DEFVAR SELECTED-WINDOW NIL "The currently selected window, or NIL.")
(DEFVAR SELECTED-IO-BUFFER NIL
  "The IO-BUFFER that input is currently being directed to.")

(DEFVAR *selected-process-priority* 0 "Priority of the selected window's process - NIL to leave it alone.")
(DEFVAR *deselected-process-priority* -1
  "The default priority for deselected windows")

(DEFVAR WHO-LINE-PROCESS CURRENT-PROCESS
  "Process that the wholine is should display,
or NIL => selected window's process.")

(DEFVAR process-is-in-error nil)

;;; Freeze wholine during loading, unfreeze later.  The LOGOUT-LIST isn't bound in the
;;; cold-load-environment.
(WHEN (BOUNDP 'LOGOUT-LIST)
  (PUSH '(SETQ WHO-LINE-PROCESS NIL) LOGOUT-LIST))

(DEFVAR LAST-WHO-LINE-PROCESS CURRENT-PROCESS
  "The last process which was displayed in the who-line.")

(DEFVAR INHIBIT-WHO-LINE NIL
  "Set this to T with CC if who line is broken.")

(DEFVAR INHIBIT-SCREEN-MANAGEMENT NIL
  "T causes screen management not to happen automatically.
This is set by DELAYING-SCREEN-MANAGEMENT.")

(DEFVAR MOUSE-BLINKER NIL
  "The blinker that is currently being used to track the mouse.")

(DEFVAR MOUSE-CURSOR-CLOSED-STATE 1) 	;1 if cursor not being drawn by microcode,
					;2 if it is

(DEFVAR MOUSE-WINDOW :UNBOUND "Window controlling the mouse, NIL if none.")

(DEFVAR MOUSE-RECONSIDER :UNBOUND
  "T => mouse process should return to overseer and decide anew
which window should get the mouse.  For use by :MOUSE-MOVES
methods, etc.")

(DEFVAR WINDOW-OWNING-MOUSE NIL
  "NIL, or window which has seized the mouse, or T if someone has
seized the mouse and can't identify himself as any particular window,
or STOP to make the mouse process do nothing.")

(DEFVAR MOUSE-SHEET NIL
  "The sheet on which the mouse is being tracked.  Usually this is a
screen.")

(DEFVAR MOUSE-PROCESS :UNBOUND
  "This global-process is in charge of the mouse.")

(DEFVAR MOUSE-HANDEDNESS :RIGHT
  "Determines which hand the mouse will be used with by the user.
Possible values: :LEFT and :RIGHT.")

;; may 9-1-88
(DEFUN MOUSE-WAKEUP ()
  "Inform mouse tracking that the screen layout has changed."
; (SETQ MOUSE-RECONSIDER T)
  (SETQ MOUSE-WAKEUP T))

;;;; Dummy function for load-time use.
;(OR (FBOUNDP 'MOUSE-WAKEUP)			;; may 9-1-88
;    (FSET' MOUSE-WAKEUP '(LAMBDA () NIL)))	;; may 9-1-88

;;; The code dealing with areas is used to make memory references more
;;; local by setting aside an area of memory for this purpose.
(DEFVAR SHEET-AREA working-storage-area
  ;dont use a customized area  PMH 2/25/88 this was (MAKE-AREA :NAME 'SHEET-AREA)
  "Area which windows and some related data are consed in.")
(DEFVAR WHO-LINE-AREA working-storage-area
  ;dont use a customized area PMH 2/25/88 this was (MAKE-AREA :NAME 'WHO-LINE-AREA)
  "Area for the who-line to cons in.")

(DEFMACRO SHEET-CONSING (&BODY BODY)
  "Execute BODY with DEFAULT-CONS-AREA bound to the area SELF is
in."
  `(LET ((DEFAULT-CONS-AREA (%AREA-NUMBER SELF)))
     . ,BODY))

(DEFVAR BLINKER-AREA working-storage-area
  ;dont use a customized area PMH 2/25/88 this was (MAKE-AREA :NAME 'BLINKER-AREA)
  "Area which blinkers are consed in.")

;;;
;;; Color support

(DEFVAR *COLOR-SYSTEM* NIL
  "This variable is true if the system has been converted to run in color.")

(DEFVAR kludge-block 1 "The control block where saturate and clamp are kludged to be")

(DEFCONSTANT white 0)
(DEFCONSTANT 12%-gray-color 1)
(DEFCONSTANT 25%-gray-color 2)
(DEFCONSTANT 33%-gray-color 3)
(DEFCONSTANT 50%-gray-color 4)
(DEFCONSTANT 66%-gray-color 5)
(DEFCONSTANT 75%-gray-color 6)
(DEFCONSTANT 88%-gray-color 7)
(DEFCONSTANT black 8)

(DEFCONSTANT dark-green 9)
(DEFCONSTANT blue 10)
(DEFCONSTANT red 11)
(DEFCONSTANT orange 12)
(DEFCONSTANT purple 13)
(DEFCONSTANT pink 14)
(DEFCONSTANT cyan 15)
(DEFCONSTANT magenta 16)
(DEFCONSTANT yellow 17)
(DEFCONSTANT light-brown 22)
(DEFCONSTANT green 19)
(DEFCONSTANT dark-blue 18)
(DEFCONSTANT dark-brown 20)
(DEFCONSTANT blue-green 21)
(DEFCONSTANT red-purple 23)

(DEFCONSTANT old-black black   "A name for the value of white in a monochrome environment")
(DEFCONSTANT OLD-WHITE 12%-gray-color "A name for the value of white for a monochrome environment")

;; NOTE: The following are no longer set for B&W system.  They will show up in Profile as color
;;  values, but who cares.  They only get used when the window is color anyway.  02/21/88 KJF
;;; >>> these are now to be PROFILE variables, initially set for b&w system
;;; >>> the function reset-default-colors changes these so that they are good defaults for color
;;; >>> They can also be change via the profile utility.
;;; >>> change these to correct defaults for B&W

;;;  window values
;;; 8/24/1987  changed from numeric values to symbols as result of code reading
;;
;; These were changed to default color values so we don't have to worry about changing them
;; when a window becomes color.  The reason we can do this is because; if a window is not a
;; color window, these values do not get used (not downloaded to H/W.)  02/21/88 KJF
(DEFPARAMETER *DEFAULT-COLOR-MAP*           nil)
(DEFPARAMETER *DEFAULT-FOREGROUND*          black "The default foreground color of a window")
(DEFPARAMETER *DEFAULT-BACKGROUND*          12%-gray-color "The default background color of a window")
(DEFPARAMETER *DEFAULT-BORDER-COLOR*        black "The default border color of a window")
;;; window label values

(defparameter *default-label-foreground* black "The default color for labels")
(defparameter *default-label-background* 25%-gray-color "The default background on which labels are drawn")

;;; menu values

(defparameter *default-menu-foreground* black "The default color of a menu")
(defparameter *default-menu-background* 25%-gray-color "The default background for a menu")
(defparameter *default-menu-label-foreground* black "The default color of a label in a menu")
(defparameter *default-menu-label-background* 50%-gray-color "The default background of on which menu labels are drawn")

;;; who line screen values

(DEFPARAMETER *default-status-foreground* 12%-gray-color "The default color for date,time,package,user, and process")
(DEFPARAMETER *default-status-background* black "The default color for the background of the who line")
(DEFPARAMETER *default-documentation-foreground* black "The default color for the who line documentation string")
(DEFPARAMETER *default-documentation-background* 33%-gray-color "The default background for the who line documentation")

;;; Color conversion initialization list

(DEFVAR *CONVERT-TO-COLOR-INITIALIZATION-LIST* nil
  "This initialization list is run by CONVERT-TO-COLOR after the color functionality is established.")

(push '(:convert-to-color *CONVERT-TO-COLOR-INITIALIZATION-LIST*)
      sys:initialization-keywords)

;;; misc variables

(DEFPARAMETER *DEFAULT-SCROLL-BAR-COLOR*    75%-gray-color "The default color for a scroll bar")
(DEFPARAMETER *default-blinker-offset*      9    "This is the offset from screen content to mouse content.")
(DEFPARAMETER *default-plane-mask*          #xFF "All bits set to one, meaning all 8 planes are enabled for output")
(DEFVAR *COLOR-MAPS* nil "A list of the currently loaded color maps.")

;; The following function could be used to set up defaults to a mostly white on black scheme.
;; I like this scheme better because it does not hurt my eyes as much.  GRH 8/12/88
;; Note that these must be set early, since some windows have their colors defined even at
;; compile time.  Or to change defaults at run time a :restore-default-colors in a
;; (:method sheet :before :expose) ought to do the trick.
(defun set-up-white-on-black-color-defaults ()
  "Set color defaults to alternate white on black scheme.  Note some existing FLAVORS may
 not get all of the new defaults."
  (setq *DEFAULT-FOREGROUND* white
	*DEFAULT-BACKGROUND* 88%-gray-color
	*DEFAULT-BORDER-COLOR* 50%-gray-color
	*default-label-foreground* white
	*default-label-background* black
	*default-menu-foreground* white
	*default-menu-background* 75%-gray-color
	*default-menu-label-foreground* white
	*default-menu-label-background* black
	*default-status-foreground* 12%-gray-color
	*default-status-background* black
	*default-documentation-foreground* 12%-gray-color
	*default-documentation-background* black
	*DEFAULT-SCROLL-BAR-COLOR* 25%-gray-color
	;; We ought to obsolete this and define *DEFAULT-BLINKER-COLOR* instead.
	;; The blinker offset could then be calculated at run time in the :before :blink
	;; method, giving a consistent color on different backgrounds - unlike now. - GRH
	*DEFAULT-BLINKER-offset* 10.
	))

;; Added for dual monitors and multiple screens by KJF on 02/10/88
(DEFVAR *current-foreground* 0
  "Current foreground color.  Used by sheet-load-registers and for
swapping foreground and background colors when using a CSIB.")

;; Added for dual monitors and multiple screens by KJF on 02/10/88
(DEFVAR *current-background* 255
  "Current background-color.  Used by sheet-load-registers and for
swapping foreground and background colors when using a CSIB.")

(DEFVAR *default-monochrome-plane* 0
  "Defines the plane which is used for the monochrome display
when using a csib.")

;; Added for dual monitors and multiple screens by KJF on 02/10/88
(DEFVAR *default-dual-monitor-monochrome-plane* 7
  "Defines the plane to be used for the monochrome monitor when
in the dual monitor mode.  This is used to determine the plane mask
to be used and how to set up color maps properly.  For example: If
plane 7 is to be used for the monochrome display, the plane mask
will be #x80 for the monochrome screen, and #x7f for the color
screen.  Also, the first 128 colors in the color map must be
duplicated exactly in the last 128 slots of the color map.")

;; Added for dual monitors and multiple screens by KJF on 02/10/88
(DEFVAR *default-dual-monitor-monochrome-plane-mask* #x80
  "This is the plane mask of the monochrome screen when in
the dual monitor mode.  This says that only plane 7 can be
written to.")

;; Added for dual monitors and multiple screens by KJF on 02/10/88
(DEFVAR *default-dual-monitor-color-plane-mask* #x7f
  "This is the plane mask of the color screen when in the dual
monitor mode.  This says that only planes 0 - 6 can be
written to.")

;; More globals for dual monitor/multiple screen support. 04/23/88 KJF.
;; >> From here ...
(DEFVAR *dual-monitors* nil
  "Flag for whether the system is being used in Dual Monitor mode or not.
Gets set when someone executes the (tv:switch-to-dual) function.")

(DEFVAR *color-who-line* nil
  "Contains a color version of who-line-screen.  Current thinking is that
only 1 color who-line is needed.")

(DEFVAR *mono-who-line* nil
  "Contains a monochrome version of who-line-screen.  Current thinking is that
only 1 monochrome who-line is needed.")

(DEFVAR PREVIOUSLY-SELECTED-WINDOWS (MAKE-ARRAY 20. :AREA PERMANENT-STORAGE-AREA)
  "This array contains the last 20 most previously selected windows ( or NIL'S )
for the screen in w:default-screen. When screens are switched, changing w:default-screen,
then PREVIOUSLY-SELECTED-WINDOWS is changed to point to the instance variable of
the screen : SCREENS-PREVIOUSLY-SELECTED-WINDOWS.")

(DEFVAR *previously-selected-screens* (MAKE-ARRAY 20. :area PERMANENT-STORAGE-AREA)
  "Contains additional screens which can be rotated through.  Like
previously-selected-windows array.")

(DEFVAR *current-screens* nil
  "This is just a list of tv:default-screen and tv:who-line-screen.")

(DEFVAR *screens-to-refresh* nil
  "A list which contains only exposed screens which should be refreshed using
TERM-CTRL-CLEAR-SCREEN.")

(DEFVAR *default-sib* 0
  "Default SIB number.  Needed for multiple sib/csib support.")

(DEFVAR *color-sprite-window* nil
  "A color version of w:sprite-window.")

(DEFVAR *mono-sprite-window* nil
  "Contains the monchrome (initial) version of w:sprite-window.")

(DEFVAR *initial-color-lisp-listener* nil
  "The listener created when (tv:create-color-screen) is executed.")

(DEFVAR *color-screen* nil
  "The screen created when (tv:create-color-screen) is executed.")

(DEFVAR *convert-color-sheet-to-monochrome* nil
  "What to do when trying to use a color sheet in a monochrome
environment.  T means to convert it to monochrome, NIL means signal
an error.  See method :sheet-legal-for-superior.")
;; >> To here.

;;; hacking necessary for color support; as the need grows we should formalize this
;;; These functions are referenced in files prior to their definition  PMH 9/11/87
(proclaim '(ftype (function (&rest t) t)
		  w:cvv-get-color		;called several times in the file SCRED2
						;it is defined in CHOICE file
		  w:select-color-with-mouse))	;called from CVV-GET-COLOR in CHOICE
                                                ;it is defined in COLOR-SELECTOR-PANE

(DEFFLAVOR SHEET
   ((SCREEN-ARRAY NIL)	;Array that output goes on.  Either a standard
			; array or a section of the physical screen.
			; May be null when deexposed if no BIT-ARRAY.
			; (microcode use).
    LOCATIONS-PER-LINE	;Number of locations per raster line (initialization use).
    OLD-SCREEN-ARRAY	;SCREEN-ARRAY when last exposed if there is no
			; BIT-ARRAY.
    (BIT-ARRAY NIL)	;"In-core" array used when sheet not exposed (may
			; be null).
    (NAME NIL)		;What this here sheet is called
    (LOCK NIL)		;Lock cell, contains unique-id of owner of lock,
			; or a list of temporary locking unique-ids.
    (LOCK-COUNT 0)	;Number of times lock is locked by this id
			;(lock is freed when 0).

    (SUPERIOR DEFAULT-SCREEN) ;Null superior is top.
    (INFERIORS NIL)

    (EXPOSED-P NIL)	;T when exposed, NIL otherwise.  In this context
			; "exposed" means that it is among the superior's
			; exposed-inferiors and the superior either has a
			; bit-array or is exposed.  T here does not
			; necessarily mean it's visible on the screen.
    (EXPOSED-INFERIORS NIL)

    (X-OFFSET NIL)	;Position relative to position of superior.
    (Y-OFFSET NIL)
    (WIDTH NIL)		;Size of sheet.  Note that these determine the
    (HEIGHT NIL)	; part of the SCREEN-ARRAY that contains
			; meaningful data.

    CURSOR-X		;Position at which to draw next character.
    CURSOR-Y

    MORE-VPOS		;Y passing here triggers MORE processing.

    (TOP-MARGIN-SIZE 0)	;Reserved region around outside of sheet (for
			; borders, etc.).
    (BOTTOM-MARGIN-SIZE 0)
    (LEFT-MARGIN-SIZE   0)
    (RIGHT-MARGIN-SIZE  0)

    (FLAGS 0)		;A fixnum containing various flags

    ;;; Font information
    BASELINE		;# raster lines from top of char cell to baseline.
    FONT-MAP		;Map from font numbers to font arrays.
    CURRENT-FONT	;Currently selected font.
    BASELINE-ADJ	;Y offset for current font to align baseline.
    LINE-HEIGHT		;Total number of raster lines per character line.
    CHAR-WIDTH		;Character width for cursor blinker + (X,Y) positioning.
    CHAR-ALUF		;ALU function for drawing characters.
    ERASE-ALUF		;ALU function for erasing characters/lines/whole thing.
    (BLINKER-LIST NIL)	;Possibly null list of blinkers on this sheet

    (DEEXPOSED-TYPEOUT-ACTION :NORMAL)
    (TEMPORARY-BIT-ARRAY NIL)
    (TEMPORARY-WINDOWS-LOCKED NIL)  ;Used for temporary windows,  this
			; is a list of all windows underneath the
			; temporary window.
    RESTORED-BITS-P
    (INVISIBLE-TO-MOUSE-P NIL)
    (SCREEN-MANAGER-SCREEN-IMAGE NIL)
    (PRIORITY NIL)
    (TIME-STAMP NIL)
    (SELECTION-SUBSTITUTE NIL)
    ;; Color hooks.
    (color-map nil)    ;;; was     (SCREEN-ARRAY-TEXT NIL)
    (plane-mask  *default-plane-mask*) ;;; added as per Keith's suggestion, was (SCREEN-ARRAY-GRAPHICS NIL)
    (color-reverse-video-state nil) ;;; added to support reverse video in color, was LOCATIONS-PER-LINE-TEXT
    (window-id nil) ;;; Add-in board support, was LOCATIONS-PER-LINE-GRAPHICS
    UNUSED-RESERVED ;;; renamed to be a place holder, was BIT-ARRAY-GRAPHICS
    (FOREGROUND-COLOR *DEFAULT-FOREGROUND*)
    (BACKGROUND-COLOR *DEFAULT-BACKGROUND*)


    )
   ()
  :ORDERED-INSTANCE-VARIABLES
  ;; OUTSIDE means that a DEFSUBST is created for all of the instance
  ;; variables to allow them to be read or written.
  :OUTSIDE-ACCESSIBLE-INSTANCE-VARIABLES
  :GETTABLE-INSTANCE-VARIABLES
  (:SETTABLE-INSTANCE-VARIABLES DEEXPOSED-TYPEOUT-ACTION CHAR-ALUF ERASE-ALUF)
  (:INITABLE-INSTANCE-VARIABLES
    NAME WIDTH HEIGHT BIT-ARRAY
    CHAR-ALUF ERASE-ALUF
    FOREGROUND-COLOR BACKGROUND-COLOR color-map plane-mask color-reverse-video-state
    LEFT-MARGIN-SIZE TOP-MARGIN-SIZE RIGHT-MARGIN-SIZE BOTTOM-MARGIN-SIZE
    SUPERIOR FONT-MAP PRIORITY)
  (:INIT-KEYWORDS :TOP :Y :BOTTOM :LEFT :SIZE :X :RIGHT :POSITION :EDGES
                  :BLINKER-P :REVERSE-VIDEO-P :CHARACTER-WIDTH
                  :CHARACTER-HEIGHT :INSIDE-SIZE :INSIDE-WIDTH
                  :INSIDE-HEIGHT :MORE-P :VSP :BLINKER-FLAVOR
                  :BLINKER-DESELECTED-VISIBILITY :INTEGRAL-P :SAVE-BITS
                  :RIGHT-MARGIN-CHARACTER-FLAG :TRUNCATE-LINE-OUT-FLAG
                  :BACKSPACE-NOT-OVERPRINTING-FLAG :CR-NOT-NEWLINE-FLAG
                  :KEYPAD-ENABLE
                  :AREA :DEEXPOSED-TYPEIN-ACTION :TAB-NCHARS
                  ) ;;; 8/24/1987 removed un-needed keyword arguments as result of code reading
  (:INSTANCE-AREA-FUNCTION SHEET-INSTANCE-AREA-FUNCTION)
  (:DEFAULT-INIT-PLIST :TAB-NCHARS 8)
  (:METHOD-COMBINATION (:OR :BASE-FLAVOR-LAST :NOTICE)
		       (:APPEND :BASE-FLAVOR-LAST :PROCESSES)
		       (:PASS-ON (:BASE-FLAVOR-LAST LM TM RM BM)
                                 :COMPUTE-MARGINS)
		       (:DAEMON-WITH-OVERRIDE :BASE-FLAVOR-LAST
					      :WHO-LINE-DOCUMENTATION-STRING))
  (:DOCUMENTATION :LOWLEVEL-MIXIN "A lowest level window type
This is the data structure known about by the microcode."))


(DEFUN SHEET-INSTANCE-AREA-FUNCTION (INIT-PLIST)
  (OR (GET INIT-PLIST :AREA) SHEET-AREA))

;;; Define functions which are a short-hand for the corresponding
;;; DEFSUBSTs which were created by the SHEET flavor.
(DEFF SHEET-X #'SHEET-X-OFFSET)
(DEFF SHEET-Y #'SHEET-Y-OFFSET)

(DEFFLAVOR SCREEN
  ((BITS-PER-PIXEL 1)	;For gray or color, default value is for black and white
   (FONT-ALIST NIL)	;Maps font purposes to symbols whose values
			; are font names.
   BUFFER		;Virtual memory address of video buffer
   CONTROL-ADDRESS	;XBUS I/O address of control register
   BUFFER-HALFWORD-ARRAY  ;One-dimensional array of 16-bit buffer hunks
   (DEFAULT-FONT *DEFAULT-FONT*)
   PROPERTY-LIST
   (X-OFFSET 0)
   (Y-OFFSET 0)
   (SUPERIOR NIL)
   (LOCATIONS-PER-LINE 32); "32 for monochrome, 256 for color")
   (LEVEL-COUNT 0)      ;This doesn't appear to be used at all in any
			; part of the window system code.
   (MOUSE-BLINKERS NIL)
   ;; screens-previously-selected-windows keeps track of the previously selected windows
   ;; for a screen.  Each screen has its own and we'll keep them separate.  02/22/88 KJF.
   ;; Cannot use name: previously-selected-windows since it is
   ;; a global, special variable.  Ditto screens-who-line-screen
   (screens-previously-selected-windows nil) ;; was UNUSED-RESERVED-3  ;; WAS   (BITS-PER-PIXEL-GRAPHICS 8.)
   (screens-who-line-screen nil) ;; was UNUSED-RESERVED-4  ;; WAS  BUFFER-TEXT
   UNUSED-RESERVED-5  ;; WAS  BUFFER-GRAPHICS
   )
  (SHEET)
  (:OUTSIDE-ACCESSIBLE-INSTANCE-VARIABLES
    BUFFER-HALFWORD-ARRAY DEFAULT-FONT
    CONTROL-ADDRESS PROPERTY-LIST FONT-ALIST
    BITS-PER-PIXEL BUFFER MOUSE-BLINKERS
    screens-previously-selected-windows screens-who-line-screen
  )
  (:INITABLE-INSTANCE-VARIABLES
    BITS-PER-PIXEL FONT-ALIST
    BUFFER CONTROL-ADDRESS BUFFER-HALFWORD-ARRAY DEFAULT-FONT
    PROPERTY-LIST LOCATIONS-PER-LINE
  )
  (:GETTABLE-INSTANCE-VARIABLES
    MOUSE-BLINKERS BUFFER BUFFER-HALFWORD-ARRAY FONT-ALIST
  )
  (:SETTABLE-INSTANCE-VARIABLES MOUSE-BLINKERS
    screens-previously-selected-windows screens-who-line-screen
  )
  (:DOCUMENTATION
    :SPECIAL-PURPOSE
    "The software data structure for the actual screen The top of a
window hierachy should be of this type.  There will be only one for
each hardware display."))


(DEFMACRO DEFINE-SHEET-FLAGS (&REST FLAGS)
  "Initialize constants for use in testing the bits of the FLAGS
  instance variable.  The arguments are each a list of 2
  components: a name and a byte specifier useful when using the LDB
  function.  The name is created with a SHEET- prefix and is the name
  of a macro which refers to the particular bits of the flag."
  ;; Generate the following code for each argument:
  ;;    (DEFMACRO SHEET-name (&OPTIONAL SHEET)
  ;;       (LDB flag
  ;;         (IF SHEET (SHEET-FLAGS SHEET) FLAGS)))
  `(eval-when (load eval compile)
	  . ,(MAPCAR #'(LAMBDA (FLAG)
			 `(DEFMACRO ,(INTERN (STRING-APPEND "SHEET-" (CAR FLAG)))
				    (&OPTIONAL SHEET)
			    `(LDB ,',(CADR FLAG)
				  ,(IF SHEET `(SHEET-FLAGS ,SHEET) 'FLAGS))))
		     FLAGS)))

(DEFINE-SHEET-FLAGS
  (EXCEPTIONS                     #o0203)  ;Reasons why typeout can't happen:
  (END-PAGE-FLAG                  #o0201)  ;Cursor is below bottom limit.
  (MORE-FLAG                      #o0301)  ;More processing needs to happen.
  (OUTPUT-HOLD-FLAG               #o0401)  ;Output may not happen on this sheet.
  (RIGHT-MARGIN-CHARACTER-FLAG    #o0501)  ;A special character (!) indicates
                                           ; wraparound.
  (TRUNCATE-LINE-OUT-FLAG         #o0601)  ;SHEET-LINE-OUT should truncate
                                           ; rather than wrap around.
  (DONT-BLINK-BLINKERS-FLAG       #o0701)  ;Don't blink blinkers on this
                                           ; sheet or its inferiors.
  (BACKSPACE-NOT-OVERPRINTING-FLAG #o1001) ;Backspace is another losenge
                                           ; character.
  (CR-NOT-NEWLINE-FLAG            #o1101)  ;CR is also.
  (DEEXPOSED-TYPEIN-NOTIFY        #o1201)  ;:DEEXPOSED-TYPEIN-ACTION :NOTIFY.
  (FORCE-SAVE-BITS                #o1301)  ;Force bit saving on first deexposed.
  (TAB-NCHARS                     #o1407)  ;Number of character widths in a tab.
  ;; The following flags are used for menus only.
  (MENU-ABORT-ON-DEEXPOSE         #o0001)  ;Do an `abort' when the menu becomes deexposed
  (MENU-COMMAND-MENU              #o0101)  ;Put blip into an IO buffer when an item is moused
  (MENU-DYNAMIC                   #o2301)  ;Allow the menu to be dynamically altered
  (MENU-HIGHLIGHTING              #o2401)  ;Highlight an item using reverse video
  (MENU-MULTICOLUMN               #o2501)  ;Multiple column menu
  (MENU-POP-UP                    #o2601)  ;Temporary shadow borders menu with hysteresis

  (KEYPAD-ENABLE                  #o2701)  ;Causes keypad characters to generate different characters.
  (MENU-PERMANENT                 #o3001)  ;Determines whether menu is permanent or temporary.
  )

#|

The following is the  layout of the  bits that make  up the flags  word.
This is getting a bit  full.  Perhaps if more  bits are needed then  the
tab-nchars field could be moved out into its instance variable.

Note that it is very  important that the order  of these fields be  kept
the same.  If one does a make-system on the TV system after changing the
ordering of these fields then the  window system probably will not  work
properly.  This is because old instances of windows would have the flags
stored one way but the flags would be referenced using the new ordering.
Of course, if  one does  a system  build from  scratch then  it is OK to
change the ordering of these fields.

   30  27  26  25  24  23  22  21  20  17  16  15  14  13  12  11  10  7   6   5   4   3   2   1   0  Octal   bit number
   24  23  22  21  20  19  18  17  16  15  14  13  12  11  10  9   8   7   6   5   4   3   2   1   0  Decimal bit number
 .---------------------------------------------------------------------------------------------------.
 | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X |
 `---------------------------------------------------------------------------------------------------'
   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   `----Menu abort on deexpose
   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   `--------Command Menu
   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   `---End of Page
   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   `-------More flag
   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   `---Output hold
   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   `-------Right margin character
   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   `---Truncate line out
   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   `-------Blinkers dont blink
   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   `---Backspace not overprinting
   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   `-------CR not newline
   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
   |   |   |   |   |   |   |   |   |   |   |   |   |   |   `---Deexposed typein action :Notify
   |   |   |   |   |   |   |   |   |   |   |   |   |   |
   |   |   |   |   |   |   |   |   |   |   |   |   |   `-------Force save bits
   |   |   |   |   |   |   6   5   4   3   2   1   0
   |   |   |   |   |   |   `---`---`---`---`---`---`---Tab nchars
   |   |   |   |   |   |
   |   |   |   |   |   `---Dynamic menu
   |   |   |   |   |
   |   |   |   |   `-------Highlighting menu
   |   |   |   |
   |   |   |   `---Multicolumn menu
   |   |   |
   |   |   `-------Pop-up menu
   |   |
   |   `-------Key-pad-enable
   |
   `---------MENU-PERMANENT

|#

(DEFMACRO SHEET-INSIDE-WIDTH (&OPTIONAL SHEET)
  "Return the distance between SHEET's left and right margins (or
SELF's, if no arg)."
  (IF SHEET
      `(- (SHEET-WIDTH ,SHEET) (SHEET-LEFT-MARGIN-SIZE ,SHEET)
	  (SHEET-RIGHT-MARGIN-SIZE ,SHEET))
      `(- WIDTH LEFT-MARGIN-SIZE RIGHT-MARGIN-SIZE)))

(DEFMACRO SHEET-INSIDE-HEIGHT (&OPTIONAL SHEET)
  "Return the distance between SHEET's top and bottom margins (or
SELF's, if no arg)."
  (IF SHEET
      `(- (SHEET-HEIGHT ,SHEET) (SHEET-TOP-MARGIN-SIZE ,SHEET)
	  (SHEET-BOTTOM-MARGIN-SIZE ,SHEET))
      `(- HEIGHT TOP-MARGIN-SIZE BOTTOM-MARGIN-SIZE)))

(DEFVAR *LANDSCAPE-MONITOR* NIL
  "T if the monitor in use is wider than it is tall")

(DEFMACRO SHEET-END-OF-PAGE-FLAG (&OPTIONAL SHEET)
  "Returns the end-of-page flag for SHEET (value is 1 or 0)."
  (IF SHEET `(SHEET-END-PAGE-FLAG ,SHEET) `(SHEET-END-PAGE-FLAG)))

;;;Sizes within margins
(DEFMACRO SHEET-INSIDE-LEFT (&OPTIONAL SHEET)
  "Return the width of SHEET's left margin (or SELF's, if no arg)."
  (IF SHEET `(SHEET-LEFT-MARGIN-SIZE ,SHEET) 'LEFT-MARGIN-SIZE))

(DEFMACRO SHEET-INSIDE-TOP (&OPTIONAL SHEET)
  "Return the width of SHEET's top margin (or SELF's, if no arg)."
  (IF SHEET `(SHEET-TOP-MARGIN-SIZE ,SHEET) 'TOP-MARGIN-SIZE))

(DEFMACRO SHEET-INSIDE-RIGHT (&OPTIONAL SHEET)
  "Return the position of SHEET's right margin (or SELF's, if no arg).
The value is relative to the left edge of the sheet."
  (IF SHEET
      `(- (SHEET-WIDTH ,SHEET) (SHEET-RIGHT-MARGIN-SIZE ,SHEET))
      `(- WIDTH RIGHT-MARGIN-SIZE)))

(DEFMACRO SHEET-INSIDE-BOTTOM (&OPTIONAL SHEET)
  "Return the position of SHEET's bottom margin (or SELF's, if no arg).
The value is relative to the top edge of the sheet."
  (IF SHEET
      `(- (SHEET-HEIGHT ,SHEET) (SHEET-BOTTOM-MARGIN-SIZE ,SHEET))
      `(- HEIGHT BOTTOM-MARGIN-SIZE)))

(DEFMACRO SHEET-TEMPORARY-P (&OPTIONAL SHEET)
  "T if SHEET (or SELF, if no arg) is a temporary window. A
temporary window is one which saves the bits of whatever is
underneath it, when it is exposed."
  `(NOT (NULL ,(IF SHEET
                   `(SHEET-TEMPORARY-BIT-ARRAY ,SHEET)
		 ;;ELSE
                 'TEMPORARY-BIT-ARRAY))))

(DEFMACRO SHEET-SUPERIOR-SCREEN-ARRAY (&OPTIONAL SHEET)
  "Return the screen array of SHEET (or SELF)'s superior."
  (LET ((SUPERIOR (IF SHEET `(SHEET-SUPERIOR ,SHEET) 'SUPERIOR)))
    `(OR (SHEET-SCREEN-ARRAY ,SUPERIOR) (SHEET-OLD-SCREEN-ARRAY ,SUPERIOR))))

(DEFMACRO SHEET-OUTPUT-HELD-P (&OPTIONAL SHEET)
  "T if SHEET's (or SELF's, if no arg) output is now being held."
  (IF SHEET
      `(OR (NOT (ZEROP (SHEET-OUTPUT-HOLD-FLAG ,SHEET)))
	   (CONSP (SHEET-LOCK ,SHEET)))
      '(OR (NOT (ZEROP (SHEET-OUTPUT-HOLD-FLAG)))
	   (CONSP LOCK))))

(DEFSUBST ARRAY-BITS-PER-PIXEL (ARRAY)
  "The number of bits per element of ARRAY, which must be a
numeric array."
  (LSH 1 (1- (%P-LDB %%ARRAY-TYPE-FIELD ARRAY))))

(DEFSUBST SHEET-BITS-PER-PIXEL (&OPTIONAL (SHEET SELF))
  "The number of bits in each pixel of SHEET (or SELF, with no arg).
Only callable when the sheet can be output on -- BEWARE!"
  (ARRAY-BITS-PER-PIXEL (SHEET-SCREEN-ARRAY SHEET)))

(DEFMACRO SHEET-LINE-NO (&OPTIONAL SHEET CURSOR-Y)
  "Return SHEET's cursor-y as a line number (or SELF's, if no arg)."
  `(FLOOR (- ,(COND (CURSOR-Y CURSOR-Y)
		    (SHEET `(SHEET-CURSOR-Y ,SHEET))
		    (T 'CURSOR-Y))
	     (SHEET-INSIDE-TOP ,SHEET))
	  ,(IF SHEET
	       `(SHEET-LINE-HEIGHT ,SHEET)
	     'LINE-HEIGHT)))

(DEFMACRO SHEET-NUMBER-OF-INSIDE-LINES (&OPTIONAL SHEET)
  "Return the number of lines that fit between SHEET's top and
bottom margins. With no arg, applies to SELF."
  `(FLOOR (SHEET-INSIDE-HEIGHT ,SHEET)
	  ,(IF SHEET `(SHEET-LINE-HEIGHT ,SHEET) 'LINE-HEIGHT)))

(DEFSUBST CHAR-CMSH-BITS (CHAR)
  "Returns the control, meta, super, hyper bits of the character object CHAR."
  (LDB %%KBD-CONTROL-META CHAR))

(DEFMACRO SHEET-TAB-WIDTH (&OPTIONAL SHEET)
  "Returns the number of char positions between tab stops on
SHEET (SELF, if no arg)."
  `(* (SHEET-TAB-NCHARS ,SHEET)
      ,(IF SHEET `(SHEET-CHAR-WIDTH ,SHEET) 'CHAR-WIDTH)))

;;;A blinker is an actor, described as follows:
(DEFFLAVOR BLINKER
	((X-POS NIL)	      ;X position of blinker (left) NIL if should
                              ; follow sheet.
	 (Y-POS NIL)	      ;Y position of blinker (top).
	 SHEET		      ;Sheet associated with blinker.
	 (VISIBILITY :BLINK) ;NIL invisible, T visible, :BLINK blinking,
                              ; :ON visible but blinking when selected,
                              ; :OFF invisibile but ...
	 (DESELECTED-VISIBILITY :ON)	;Blinker's visibility when the sheet
                              ; it is on is not selected, reasonable values
                              ; :ON, :OFF and :BLINK.
	 (HALF-PERIOD 15.)    ;Time interval (60ths) between phase blinks.
	 (PHASE NIL)	      ;NIL not visible, anything else visible in some
                              ; form (Complementing blinker has only two
                              ; phases, uses NIL, T).
	 (TIME-UNTIL-BLINK 0) ;Time interval until next blink.  NIL means not
                              ; blinking, the clock level should ignore
                              ; this blinker.
	 (FOLLOW-P NIL)       ;Follows cursor for text input.
         (blinker-offset *default-blinker-offset*)
	 )
	()
  :ORDERED-INSTANCE-VARIABLES :OUTSIDE-ACCESSIBLE-INSTANCE-VARIABLES
  (:INITABLE-INSTANCE-VARIABLES X-POS Y-POS SHEET VISIBILITY FOLLOW-P blinker-offset)
  (:GETTABLE-INSTANCE-VARIABLES X-POS Y-POS SHEET VISIBILITY FOLLOW-P blinker-offset)
  (:SETTABLE-INSTANCE-VARIABLES DESELECTED-VISIBILITY HALF-PERIOD blinker-offset)
  (:REQUIRED-METHODS :BLINK :SIZE)
  (:SELECT-METHOD-ORDER :BLINK))


(DEFMACRO BLINKER-SET-CURSORPOS (BLINKER X Y)
  "Move BLINKER to position X, Y (relative to margins of
BLINKER's sheet)."
  `(SEND ,BLINKER :SET-CURSORPOS ,X ,Y))

(DEFMACRO BLINKER-READ-CURSORPOS (BLINKER)
  "Return BLINKER's X, Y position (relative to margins of
BLINKER's sheet)."
  `(SEND ,BLINKER :READ-CURSORPOS))

(DEFMACRO BLINKER-SET-VISIBILITY (BLINKER VISIBILITY)
  "Set visibility of BLINKER to VISIBLITY."
  `(SEND ,BLINKER :SET-VISIBILITY ,VISIBILITY))

(DEFMACRO BLINK (BLINKER)
  `(SEND ,BLINKER :BLINK))

(DEFMACRO BLINKER-SET-SIZE (BLINKER WIDTH HEIGHT)
  "Set size of BLINKER to WIDTH by HEIGHT."
  `(SEND ,BLINKER :SET-SIZE ,WIDTH ,HEIGHT))

(DEFMACRO BLINKER-SET-CHARACTER (BLINKER FONT CHAR)
  "Set character BLINKER displays as to CHAR, in FONT.  Applies
only to character blinkers."
  `(SEND ,BLINKER :SET-CHARACTER ,CHAR ,FONT))

(DEFMACRO BLINKER-SET-SHEET (BLINKER SHEET)
  "Set the sheet BLINKER moves on to SHEET."
  `(SEND ,BLINKER :SET-SHEET ,SHEET))

;;; This macro generates the prologue code that most of the
;;; interesting blinker methods need.
(DEFMACRO WITH-BLINKER-READY (DO-NOT-OPEN-P &BODY BODY)
  "Execute BODY after preparing to modify SELF, a blinker.
DO-NOT-OPEN-P non-NIL inhibits removing SELF from the screen, in
case the caller wishes to avoid doing so if it turns out that no
change needs to be made."
  `(LET ((INHIBIT-SCHEDULING-FLAG T))
     (DO () ((OR (NOT (SHEET-OUTPUT-HELD-P SHEET))
		 (NULL PHASE)))
       (SETQ INHIBIT-SCHEDULING-FLAG NIL)
       (SEND SHEET :OUTPUT-HOLD-EXCEPTION)
       (SETQ INHIBIT-SCHEDULING-FLAG T))
     ,@(IF (NOT DO-NOT-OPEN-P)
	   `((OPEN-BLINKER SELF)))
     (PROG1 (PROGN . ,BODY)
	    ,(OR DO-NOT-OPEN-P '(SETQ TIME-UNTIL-BLINK 0)))))

(DEFFLAVOR RECTANGULAR-BLINKER
	((WIDTH NIL)		;The width
	 (HEIGHT NIL))
	(BLINKER)
  (:INITABLE-INSTANCE-VARIABLES WIDTH HEIGHT)
  (:DOCUMENTATION :COMBINATION
   "A blinker that displays as a solid rectangle."))

(DEFFLAVOR MOUSE-BLINKER-MIXIN ((X-OFFSET 0) (Y-OFFSET 0)) ()
  (:REQUIRED-FLAVORS BLINKER)
  :INITTABLE-INSTANCE-VARIABLES
  (:DOCUMENTATION
   :MIXIN
   "Blinker that is capable of being MOUSE-BLINKER"))

(DEFFLAVOR MOUSE-BLINKER-FAST-TRACKING-MIXIN () (MOUSE-BLINKER-MIXIN)
  (:included-FLAVORS BLINKER)	; So compiler knows these instance variables are unmapped.
  (:DOCUMENTATION :MIXIN
     "Blinker that is capable of being MOUSE-BLINKER and gets
tracked by microcode."))

;;;Who line variables
(DEFVAR WHO-LINE-WINDOW)	;Sheet used for writing the who line
(DEFVAR WHO-LINE-RUN-STATE "")	;Variable containing the current state
                                ; (RUN, STOP, TYI, etc.)
;(DEFVAR WHO-LINE-RUN-LIGHT-LOC);Contains the address of the run light under
                                ; the who line (moved to COLD.LISP).
(DEFVAR WHO-LINE-LIST)		;List of WHO-LINE-ITEM's, see DEFSTRUCT below

(DEFSTRUCT (WHO-LINE-ITEM (:type :LIST) (:CONSTRUCTOR NIL) (:CONC-NAME NIL)
			  (:ALTERANT ALTER-WHO-LINE-ITEM) (:PREDICATE NIL) (:COPIER NIL))
  ;; One for each field of the who-line
  WHO-LINE-ITEM-FUNCTION			;Function to be called, see WHO-LINE-UPDATE
  WHO-LINE-ITEM-STATE				;Previous contents, to save time
  WHO-LINE-ITEM-LEFT				;Left-hand bit address
  WHO-LINE-ITEM-RIGHT)				;Right-hand bit address
;More fields may exist, depending on the function

;;; Fonts.
;;; A font array may not be displaced or anything hairy like that,
;;; because it is looked at directly by microcode. Its array leader
;;; contains:
(DEFSTRUCT (FONT :NAMED (:type :ARRAY-LEADER) (:SIZE-SYMBOL FONT-LEADER-SIZE) (:CONC-NAME NIL)
   (:ALTERANT ALTER-FONT) (:PREDICATE NIL) (:COPIER NIL))
	FONT-FILL-POINTER	;1 plus highest character code defined in font.
				;At present, must be at least 200.
	FONT-NAME		;Name.  This is supposed to be the symbol in
                                ; the FONTS package whose value is this font.
	FONT-CHAR-HEIGHT	;Character cell height.
	FONT-CHAR-WIDTH		;Character cell width (used if
                                ; char-width-table is nil).
	FONT-RASTER-HEIGHT	;Raster height.
	FONT-RASTER-WIDTH	;Raster width.
	FONT-RASTERS-PER-WORD	;Floor 32./raster width (# rows per word).
	FONT-WORDS-PER-CHAR	;Ceiling raster height/#5 (# words per char).
	FONT-BASELINE		;# Raster lines down from top to align
				; with other fonts.
	FONT-CHAR-WIDTH-TABLE	;NIL or array pointer to character width table.
	FONT-LEFT-KERN-TABLE	;NIL or array pointer to left kern table.
	FONT-INDEXING-TABLE	;NIL or array pointer to index table.  This is
				;used for characters whose raster is > 32 wide.
				;Use real char code to look up char code for
				;raster purposes in the indexing table.  Draw
				;several columns, until raster for succeeding
				;character is reached.  Index table length
				;must be GREATER than font-fill-pointer
				;so as to handle end condition right.
	FONT-NEXT-PLANE		;NIL or font containing next higher plane
				; of this font.  COMPLETELY OBSOLETE.
	FONT-BLINKER-WIDTH	;Default width for blinkers.
	FONT-BLINKER-HEIGHT	;Default height for blinkers.
	FONT-CHARS-EXIST-TABLE	;Array of bits saying which chars
				; "really exist".  NIL means not in use, so
				; all chars must be assumed to exist.
	)
;;; The data part of the array contains an integral number of words
;;; per character.  Each word contains an integral number of rows of
;;; raster, right adjusted and processed from right to left. All 32
;;; bits of each Q in this array are used.  For easiest processing
;;; by Lisp programs, it should be of 1-bit byte array type.

;;; %DRAW-CHAR only works for raster widths of at most 32. because
;;; that is the most that can be shifted without overlapping 3 TV
;;; buffer words.  For larger widths it traps to ILLOP.  Wider
;;; characters are drawn by drawing several narrow characters side
;;; by side.  See the comment next to FONT-INDEXING-TABLE for how
;;; this is done.

;;; Named-structure handler
(DEFUN (:PROPERTY FONT NAMED-STRUCTURE-INVOKE) (OP &OPTIONAL SLF ARG1 &REST IGNORE)
  (CASE OP
    (:WHICH-OPERATIONS '(:PRINT-SELF))
    ((:PRINT-SELF) (PRINTING-RANDOM-OBJECT (SLF ARG1 :TYPEP) (PRINC (FONT-NAME SLF) ARG1)))
    (OTHERWISE (FERROR () "~S unknown message to ~S" OP SLF))))

;;; Define a function which will return T when its argument is a font object.
(PROCLAIM '(inline font-object-p))
(DEFUN FONT-OBJECT-P (OBJECT)
   (TYPEP OBJECT 'FONT))

;;; Grab the lock on a sheet
(DEFMACRO LOCK-SHEET ((SHEET) &BODY BODY)
  "Execute BODY with SHEET locked."
  `(UNWIND-PROTECT
     (PROGN (SHEET-GET-LOCK ,SHEET)
       . ,BODY)
     (SHEET-RELEASE-LOCK ,SHEET)))

(DEFUN SHEET-ME-OR-MY-KID-P (SHEET ME)
  "T if SHEET is ME or an inferior to any number of levels of ME."
  ;; Start at SHEET and go up the tree to find ME.
  (DO ((SHEET SHEET (SHEET-SUPERIOR SHEET)))
      ((NULL SHEET) NIL)
    (AND (EQ SHEET ME) (RETURN T))))

(PROCLAIM '(inline sheet-can-get-lock))
(DEFUN SHEET-CAN-GET-LOCK (SHEET &OPTIONAL (UNIQUE-ID CURRENT-PROCESS))
  "Returns T if a sheet's lock can be gotten (and its inferiors' locks,
too).  Should be called with interrupts inhibited if it's to be
meaningful."
  ;; Make the compile not warn about the recursive use of this function.
  (DECLARE (NOTINLINE SHEET-CAN-GET-LOCK))
  (OR (EQ (SHEET-LOCK SHEET) UNIQUE-ID)
      (SHEET-CAN-GET-LOCK-INTERNAL SHEET UNIQUE-ID SHEET)))

(DEFUN SHEET-CAN-GET-LOCK-INTERNAL (SHEET UID WITH-RESPECT-TO)
  (LET ((LOCK (SHEET-LOCK SHEET)))
    (COND ((OR (NULL LOCK)
	       ;; If window is temp locked, the current sheet isn't the
	       ;; top-level one, and all of the temp lockers are inferiors
	       ;; of the top-level sheet, then it's ok to lock this sheet,
	       ;; so recurse.
	       (AND (CONSP LOCK)
		    (NEQ SHEET WITH-RESPECT-TO)
		    (NOT (DOLIST (I LOCK)
			   (OR (SHEET-ME-OR-MY-KID-P SHEET WITH-RESPECT-TO)
			       (RETURN T))))))
	   (NOT (DOLIST (I (SHEET-INFERIORS SHEET))
		  (UNLESS (OR (EQ (SHEET-LOCK i) uid)
			      (SHEET-CAN-GET-LOCK-INTERNAL I UID WITH-RESPECT-TO))
		    (RETURN T)))))
	  (T NIL))))


;;; this function is designed for future expandability, for example to 24-bit-color
;; Added ASSERT and documentation on 04/10/88 KJF.
(DEFUN get-display-type (sheet)
  "Determine sheet type from locations-per-line.  This is used by the macro
tv:color-system-p to see if a sheet is a color one or not."
  (ASSERT sheet (sheet) "SHEET passed in as NIL.  It should be a window instance.")
  (LET ((locations-per-line (sheet-locations-per-line sheet)))
    (COND ((EQL locations-per-line 32.) :monochrome)
	  ((EQL locations-per-line 256.) :8-bit-color)
	  (t nil))))

(defmacro color-system-p (sheet)
  `(let ((display-type (get-display-type ,sheet)))
     (if (neq display-type :monochrome)
	 display-type
	 nil)))

;; >> Same code, better name.  Should be used in place of color-system-p.
;; In release 4.1, with multiple screen support, monochrome and color screens can
;; coexist, so the system is no longer strictly monochrome or color as was in 3.2.
;; 04/23/88 KJF.
(DEFMACRO color-sheet-p (sheet)
  "Returns NIL if SHEET is not a valid color SHEET.  This is determined
by locations-per-line of sheet.  If locations-per-line is 32, then it is a
monochrome sheet, if 256, then it is color."
  `(LET ((display-type (get-display-type ,sheet)))
     (IF (NOT (EQ  display-type :monochrome))
	 display-type
	 nil)))

;;; ********* Attention ! *********
;;; This function is redefined by the MMON system.
;;; If any change is made here, be sure to update the MMON version also.
;;; ********* Attention ! *********
;;;
;; Modified for dual monitors and multiple screens by KJF on 02/10/88
(DEFUN sheet-load-registers (SHEET)
  "Load foreground, background, transparency, and plane-mask registers
with current sheet values.  If sheet is B&W - 1 bit - then *current-foreground*
and *current-background* are loaded into the apropriate registers."
  (let ((f (IF (color-system-p sheet) (sheet-foreground-color sheet) *current-foreground*))
        (b (IF (color-system-p sheet) (sheet-background-color sheet) *current-background*))
	(m (sheet-plane-mask sheet)))
    (WHEN sib-is-csib
      (set-foreground-color-register f)
      (set-background-color-register b)
      (set-transparency-register b)
      ;; LOGAND'ing prevents overridding the screens' plane-mask.  04/10/88 KJF.
      (SEND sheet :write-plane-mask (LOGAND (sheet-plane-mask (get-screen sheet)) m)))))

;;; Define a macro that:
;;;     Preserves the current foreground color
;;;     Sets up the new color
;;;     call the function as it normally would be called
;;;     Restores color

;;; this macro is used a lot by SHWARM functions to add the optional color argument
;;; 8/24/87 removed tv: prefix as a result of code reading
;;; 8/24/87 added unwind protect
;; 1/9/88 ab.  Use &BODY BODY for implicit PROGN.
(DEFMACRO prepare-color ((sheet color) &body body)
  `(LET ((save-foreground (sheet-foreground-color ,sheet)))
     (UNWIND-PROTECT
	 (progn
	   (if ,color
	       (SETF (sheet-foreground-color ,sheet) ,color))
	   . ,body)
       (if ,color
	   (SETF (sheet-foreground-color ,sheet) save-foreground)))))


;;; Allow output to a sheet
(DEFMACRO SHEET-IS-PREPARED ((SHEET) &BODY BODY)
  "Execute BODY, telling the microcode to treat SHEET as
prepared.  Should only be used with XOR'ing, and with interrupts
off."
  `(LET ((SYS:CURRENTLY-PREPARED-SHEET ,SHEET))
     . ,BODY))

(DEFUN SHIFT-INTO-TEXT-MODE     (SHEET) SHEET)
(DEFUN SHIFT-INTO-GRAPHICS-MODE (SHEET) (sheet-load-registers sheet))

;;; Open up a sheet
(DEFVAR PREPARED-SHEET NIL)
(defvar *prepare-sheet-command-threshold* 5
  "Prepare sheet will do a process wait if there is not room for this many commands in the display-io
   queue on a microExplorer and interrupts were not turned off before entering.")

(DEFMACRO PREPARE-SHEET ((SHEET) &BODY BODY)
  "Execute BODY with SHEET prepared for output.  The microcode
output primitives output to the prepared sheet."
  `(LET ((old-inhibit-scheduling-flag inhibit-scheduling-flag)
	 (INHIBIT-SCHEDULING-FLAG T))

     ;; if this is a mx we should wait until it is likely there is room in the
     ;; queue for some number of commands (unless we are already in a no interrupts situation).  *BJ*
     (unless (or (not (si:addin-p))
		 old-inhibit-scheduling-flag)
       (add:wait-port-ready :prepare-sheet (add:find-channel 'display-io) *prepare-sheet-command-threshold*))
     (AND (OR (NEQ PREPARED-SHEET ,SHEET)
	      (NOT (ZEROP (SHEET-OUTPUT-HOLD-FLAG ,SHEET)))
	      (NOT (SHEET-CAN-GET-LOCK ,SHEET)))
	  (SHEET-PREPARE-SHEET-INTERNAL ,SHEET))
     (SETQ PREPARED-SHEET ,SHEET)
     (sheet-load-registers ,sheet)  ;; was (SHIFT-INTO-GRAPHICS-MODE ,SHEET) 02/17/88 KJF.
     (MULTIPLE-VALUE-PROG1
       (SHEET-IS-PREPARED (,SHEET)
           . ,BODY)
       (SHIFT-INTO-TEXT-MODE ,SHEET))))

;;; Redirects a screen array
(DEFMACRO REDIRECT-ARRAY (ARRAY TYPE WIDTH HEIGHT DISPLACED-TO DISPLACED-INDEX-OFFSET)
  "Modify the indirect bit-array ARRAY as to what it indirects
to.  The new array type is TYPE, the new width and height as
specified.  The remaining args are passed along to ADJUST-ARRAY."
  (DECLARE (IGNORE TYPE))
  (LET ((DIM-LIST (GENSYM)))
  `(WITHOUT-INTERRUPTS
     (WITH-STACK-LIST (,DIM-LIST ,HEIGHT ,WIDTh)
       (SETQ SYS:%CURRENT-SHEET NIL)
       (ADJUST-ARRAY ,ARRAY ,DIM-LIST
		     :DISPLACED-TO ,DISPLACED-TO
		     :DISPLACED-INDEX-OFFSET ,DISPLACED-INDEX-OFFSET)))))

;;; Force access to a sheet and execute the code within.  If access cannot be
;;; forced, then the code is not executed.  Forcing access means binding off
;;; the output hold flag if the sheet is deexposed and has a bit-save array.
;;; The code is also executed of the sheet is exposed and not output-held.
(DEFMACRO SHEET-FORCE-ACCESS ((SHEET IGNORE) &BODY BODY)
  "Execute BODY, outputting to SHEET whether SHEET is exposed
or not.  This does so even if SHEET does not ordinarily allow output
while deexposed.  If sheet is deexposed and has no bit array, then
the body is not executed at all.  (But then SHEET will refresh
completely when it is exposed.)"
  `(LOCK-SHEET (,SHEET)
       ;; Sheet can't have temporary lock here as we own lock, so
       ;; SHEET-OUTPUT-HELD-P not required for proper operation.
       (LET ((.OLD.OUTPUT.HOLD. (SHEET-OUTPUT-HOLD-FLAG ,SHEET)))
	 (COND ((SHEET-SCREEN-ARRAY ,SHEET)
		(UNWIND-PROTECT
		  (PROGN (SETF (SHEET-OUTPUT-HOLD-FLAG ,SHEET) 0)
			 . ,BODY)
		  (SETF (SHEET-OUTPUT-HOLD-FLAG ,SHEET)
                        .OLD.OUTPUT.HOLD.)))))))

(DEFVAR *DEFAULT-READ-WHOSTATE* "Keyboard"
  "May be rebound to provide an alternate whostate (what's printed in the
wholine next to the package prompt) while waiting for input from the keyboard.")

(DEFVAR kbd-tyi-hook nil)			;This is a crock, but I suppose someone might want to...

(DEFPARAMETER initial-repeat-delay 30
	      "60ths of a second before repeating starts.  Set this to 0 to shut off
the repeat capability.")

(DEFPARAMETER continuous-repeat-delay 1. ;; may 03/27/89 was 2.
	      "Number of 60ths of a second to delay before repeating again.")

;;; I/O buffer stuff
(DEFSTRUCT (IO-BUFFER :ARRAY-LEADER :NAMED (:CONSTRUCTOR NIL) (:SIZE-SYMBOL IO-BUFFER-LEADER-SIZE)
  (:CONC-NAME NIL)  (:ALTERANT ALTER-IO-BUFFER) (:PREDICATE NIL)
  (:COPIER NIL))
  IO-BUFFER-FILL-POINTER	;Fill pointer, unused
  IO-BUFFER-SIZE		;Size of IO buffer (max index + 1)
				; All pointer's are modulo this.
  IO-BUFFER-INPUT-POINTER	;Index in which data is next stored.
  IO-BUFFER-OUTPUT-POINTER	;Index from which data is next to be taken
				; If out ptr = inp ptr, then the buffer
				; is empty.  If inp ptr + 1 = out ptr, then
				; the buffer is full (This wastes a location
				; when the buffer is full).
				; Actual pointer manipulation should be done
				; with interrupts disabled.
  IO-BUFFER-INPUT-FUNCTION	;If non-NIL, function to be run on inputing
				; data.
  IO-BUFFER-OUTPUT-FUNCTION	;If non-NIL, function to be run when taking
				; data out.
  IO-BUFFER-STATE		;NIL means ok to put data in.
				; T means data may not be put in or taken out.
				; :INPUT means data may only be put in.
				; :OUTPUT means data may only be taken out.
  IO-BUFFER-PLIST		;Property list used to hold various bits of
				; information about the buffer (e.g. whether
				; in super image mode).
  IO-BUFFER-LAST-INPUT-PROCESS	;The last process that did input to here.
  IO-BUFFER-LAST-OUTPUT-PROCESS	;The last process that did output from here.
  IO-BUFFER-RECORD		;Records last so many input characters.
  )

(DEFPARAMETER IO-BUFFER-RECORD-LENGTH 60
              "Number of last input characters to record in each IO buffer.")

(DEFSUBST IO-BUFFER-RECORD-POINTER (INPUT-RECORD)
  "Index of last slot of INPUT-RECORD stored in."
  (ARRAY-LEADER INPUT-RECORD 1))

(DEFMACRO IO-BUFFER-EMPTY-P (BUFFER)
  "T if io-buffer BUFFER is empty."
  `(= (IO-BUFFER-INPUT-POINTER ,BUFFER)
      (IO-BUFFER-OUTPUT-POINTER ,BUFFER)))

(DEFMACRO IO-BUFFER-FULL-P (BUFFER)
  "T if io-buffer BUFFER is full (no more can be put in it)."
  ;; Always leave room for at one unget to be done
  `(= (REM (+ (IO-BUFFER-INPUT-POINTER ,BUFFER) 2) (IO-BUFFER-SIZE ,BUFFER))
      (IO-BUFFER-OUTPUT-POINTER ,BUFFER)))

(DEFMACRO WITH-SHEET-DEEXPOSED ((SHEET) &BODY BODY)
  "Execute BODY with SHEET deexposed.   SHEET will be reexposed
afterward if it was exposed to begin with. Many kinds of changes to
SHEET are simpler to make if you know that SHEET is not
exposed."
  `(LET ((.STATUS. (SEND ,SHEET :STATUS)))
     (DELAYING-SCREEN-MANAGEMENT
      (UNWIND-PROTECT
	(PROGN (SEND ,SHEET :DEEXPOSE :DEFAULT :NOOP)
	       . ,BODY)
	(SEND ,SHEET :SET-STATUS .STATUS.)))))

(DEFMACRO PRESERVE-SUBSTITUTE-STATUS (WINDOW &BODY BODY)
  "Execute BODY, then select WINDOW if it (or its substitute)
used to be selected."
  `(LET* ((.WINDOW. ,WINDOW)
	  (.STATUS. (SEND .WINDOW. :SELF-OR-SUBSTITUTE-SELECTED-P)))
     (UNWIND-PROTECT
       (PROGN . ,BODY)
       (IF .STATUS. (SEND .WINDOW. :SELECT)))))

(DEFMACRO WITH-SELECTION-SUBSTITUTE ((WINDOW FOR-WINDOW) &BODY BODY)
  "Execute BODY with WINDOW as a selection substitute for
FOR-WINDOW.  While FOR-WINDOW has the selection substitute, the
substitute will be selected whenever FOR-WINDOW would have been
selected."
  `(LET* ((.WINDOW. ,WINDOW)
	  (.FOR-WINDOW. ,FOR-WINDOW)
	  (.GO-AHEAD-AND-CHANGE-THE-SUBSTITUTE.
	    ;; If both windows go to the same window then don't bother changing
	    ;; the selection substitute at all.  This does the right thing when
	    ;; the caller goofs up and has a looping selection-substitute, by
	    ;; not doing the selection substitute at all.
	    (OR (NULL .WINDOW.)
		(NEQ
		  (SEND .FOR-WINDOW. :ULTIMATE-SELECTION-SUBSTITUTE)
		  (SEND     .WINDOW. :ULTIMATE-SELECTION-SUBSTITUTE))))
	  (.OSTATUS. (AND .WINDOW. (SEND .WINDOW. :STATUS)))
	  (.OSUBST. (SEND .FOR-WINDOW. :SELECTION-SUBSTITUTE)))
     (IF .GO-AHEAD-AND-CHANGE-THE-SUBSTITUTE.
	 (SEND .FOR-WINDOW. :SET-SELECTION-SUBSTITUTE .WINDOW.))
     (UNWIND-PROTECT
       (PROGN . ,BODY)
       (IF .GO-AHEAD-AND-CHANGE-THE-SUBSTITUTE.
	   (DELAYING-SCREEN-MANAGEMENT
	     (SEND .FOR-WINDOW. :SET-SELECTION-SUBSTITUTE .OSUBST.)
	     (IF .WINDOW. (SEND .WINDOW. :SET-STATUS .OSTATUS.)))))))

;;;Temporarily select a window
(DEFMACRO WINDOW-CALL ((WINDOW FINAL-ACTION . FINAL-ACTION-ARGS) &BODY BODY)
  "Select WINDOW then execute BODY.  Afterward, send a
FINAL-ACTION message.  After BODY, WINDOW is sent the FINAL-ACTION
operation with FINAL-ACTION-ARGS as args.  :DEACTIVATE is frequently
used for FINAL-ACTION."
  `(LET ((.CURRENT-WINDOW. SELECTED-WINDOW))
     (UNWIND-PROTECT
       (PROGN
	 (SEND ,WINDOW :SELECT)
	 . ,BODY)
       ;; Reselect old window -- be careful not to reselect if we
       ;; aren't still the currently selected window, thus
       ;; preventing spurious selection.
       ,(IF FINAL-ACTION
	    `(DELAYING-SCREEN-MANAGEMENT
	       (LET ((.FLAG. (SHEET-ME-OR-MY-KID-P SELECTED-WINDOW ,WINDOW)))
		 (SEND ,WINDOW ',FINAL-ACTION . ,FINAL-ACTION-ARGS)
		 (AND .CURRENT-WINDOW. .FLAG.
                      (SEND .CURRENT-WINDOW. :SELECT NIL))))
	    `(AND .CURRENT-WINDOW.
                  (SHEET-ME-OR-MY-KID-P SELECTED-WINDOW ,WINDOW)
		  (SEND .CURRENT-WINDOW. :SELECT NIL))))))

(DEFMACRO WINDOW-MOUSE-CALL
          ((WINDOW FINAL-ACTION . FINAL-ACTION-ARGS) &BODY BODY)
  "Mouse-select WINDOW then execute BODY.  Afterward, send a
FINAL-ACTION message.  This is different from WINDOW-CALL in that it
selects WINDOW using the :MOUSE-SELECT operation, appropriate if
this is being done in response to some sort of mouse command.  After
BODY, WINDOW is sent the FINAL-ACTION operation with
FINAL-ACTION-ARGS as args.  :DEACTIVATE is frequently used for
FINAL-ACTION."
  `(LET ((.CURRENT-WINDOW. SELECTED-WINDOW))
     (UNWIND-PROTECT
       (PROGN
	 (SEND ,WINDOW :MOUSE-SELECT)
	 . ,BODY)
       ,(IF FINAL-ACTION
	    `(DELAYING-SCREEN-MANAGEMENT
	       (SEND ,WINDOW ',FINAL-ACTION . ,FINAL-ACTION-ARGS)
	       (AND .CURRENT-WINDOW. (SEND .CURRENT-WINDOW. :SELECT NIL)))
	    `(AND .CURRENT-WINDOW. (SEND .CURRENT-WINDOW. :SELECT NIL))))))

(DEFMACRO WINDOW-CALL-WITH-SELECTION-SUBSTITUTE
	  ((WINDOW FINAL-ACTION . FINAL-ACTION-ARGS) &BODY BODY)
  "Select WINDOW making it the selection substitute for the
currently selected window, then execute BODY.  After BODY, WINDOW is
sent the FINAL-ACTION operation with FINAL-ACTION-ARGS as args.
:DEACTIVATE is frequently used for FINAL-ACTION. While within this
form, WINDOW will be selected whenever the previously selected
window would have been selected."
  `(LET ((.CURRENT-WINDOW. SELECTED-WINDOW)
	 (.Old-SUBST. (AND SELECTED-WINDOW
                       (SEND SELECTED-WINDOW :SELECTION-SUBSTITUTE))))
     ;;check to make sure that the window is really selectable -- GSM 17 Dec 85
     ;;before this form was added, if the window was not selectable, this macro was just an elaborate no-op
     (CHECK-ARG ,window (SEND ,window :operation-handled-p :process)
		"a selectable window.  The first argument to tv:window-call-with-selection-substitute must be an instantiation of a window flavor that includes select-mixin")
     (UNWIND-PROTECT
	 (PROGN
	   (SEND ,WINDOW :SELECT)
	   (WHEN .CURRENT-WINDOW.
              (SEND .CURRENT-WINDOW. :SET-SELECTION-SUBSTITUTE ,WINDOW))
	   . ,BODY)
       (DELAYING-SCREEN-MANAGEMENT
	 (WHEN .CURRENT-WINDOW.
            (SEND .CURRENT-WINDOW. :SET-SELECTION-SUBSTITUTE .Old-SUBST.))
	 ;; Reselect old window -- be careful not to reselect if we
	 ;; aren't still the currently selected window, thus
	 ;; preventing spurious selection.
	 ,(IF FINAL-ACTION
	      `(LET ((.FLAG. (SHEET-ME-OR-MY-KID-P SELECTED-WINDOW ,WINDOW)))
		 (SEND ,WINDOW ',FINAL-ACTION . ,FINAL-ACTION-ARGS)
		 (AND .CURRENT-WINDOW. .FLAG.
                      (SEND .CURRENT-WINDOW. :SELECT NIL)))
	    `(AND .CURRENT-WINDOW.
                  (SHEET-ME-OR-MY-KID-P SELECTED-WINDOW ,WINDOW)
		  (SEND .CURRENT-WINDOW. :SELECT NIL)))))))


;;; Maybe this should go somewhere else.
(DEFMACRO DOPLIST ((PLIST PROP IND) &BODY BODY)
  `(DO ((PLIST ,PLIST (CDDR PLIST))
	(,PROP)
	(,IND))
       ((NULL PLIST))
     (SETQ ,IND (CAR PLIST)
	   ,PROP (CADR PLIST))
     . ,BODY))

;;; There are certain kinds of windows that are associated with
;;; screens.  These include the system menu, and associated
;;; windows.  This a facility for defining those kinds of windows,
;;; and allocating them automatically.

(DEFMACRO DEFWINDOW-RESOURCE (NAME PARAMETERS &REST OPTIONS &AUX (CONSTRUCTOR NIL) (INITIAL-COPIES 1)
  (CHECKER 'CHECK-UNLOCKED-WINDOW-RESOURCE))
  "Define a resource (a la DEFRESOURCE) of windows of a given
flavor.  The resource is defined with the specified parameters and
one additional one, which is the desired superior.  When you
allocate a window from this resource, you can specify the superior
as well as the other parameters, or you can let it default to
MOUSE-SHEET.  Options are:
	:INITIAL-COPIES -- number of windows to create initially.
		Default is one, which is made an inferior of
		DEFAULT-SCREEN.
	:CONSTRUCTOR -- as with DEFRESOURCE.
	:MAKE-WINDOW -- value is list of flavor name followed by
		keyword args.  The default constructor passes this
		list to MAKE-WINDOW, evaluating the elements of it.
	:REUSABLE-WHEN (one of :DEEXPOSED or :DEACTIVATED).  The
		default is to be reusable when nobody is using it
		and it is not locked.  If you specify :DEEXPOSED or
		:DEACTIVATED, it means that a window that is not
		exposed or not active can automatically be reused."
  (LOOP FOR (KEYWORD VALUE) ON OPTIONS BY 'CDDR DO
        (CASE KEYWORD
          (:INITIAL-COPIES (SETQ INITIAL-COPIES VALUE))
          (:CONSTRUCTOR (SETQ CONSTRUCTOR VALUE))
          ((:MAKE-WINDOW :WINDOW-CREATE);:WINDOW-CREATE obsolete old name.

           (SETQ CONSTRUCTOR
                 `(MAKE-WINDOW ',(CAR VALUE) ,:SUPERIOR SUPERIOR
                    . ,(LOOP FOR (KEYWORD VALUE) ON (CDR VALUE) BY 'CDDR COLLECT `',KEYWORD
                         COLLECT VALUE))))
          (:REUSABLE-WHEN
           (SETQ CHECKER
                 (CASE VALUE
                   (:DEEXPOSED 'CHECK-DEEXPOSED-WINDOW-RESOURCE)
                   (:DEACTIVATED 'CHECK-DEACTIVATED-WINDOW-RESOURCE)
                   (OTHERWISE
                    (FERROR ()
                            "~S ~S - only :DEEXPOSED and ~
					     :DEACTIVATED are allowed"
                            KEYWORD VALUE)))))
          (OTHERWISE (FERROR () "~S invalid DEFWINDOW-RESOURCE option" KEYWORD))))
  (OR CONSTRUCTOR
      (FERROR ()
              "DEFWINDOW-RESOURCE requires either the :CONSTRUCTOR or~@
			       the :MAKE-WINDOW option."))
  `(PROGN
    'COMPILE
    (PUSH ',NAME WINDOW-RESOURCE-NAMES)
    (DEFRESOURCE ,NAME
                 (,@PARAMETERS
                  . ,(IF (MEMBER '&OPTIONAL PARAMETERS :TEST #'EQ) '((SUPERIOR MOUSE-SHEET))
                       '(&OPTIONAL (SUPERIOR MOUSE-SHEET))))
                 ,:DEALLOCATOR CLEAN-OUT-IO-BUFFER
                 ,:INITIAL-COPIES ,INITIAL-COPIES ,:CONSTRUCTOR ,CONSTRUCTOR ,:CHECKER ,CHECKER)))

;;; This gets a list of all window resources.
;;; so that :CHANGE-OF-DEFAULT-FONT can find the windows even when
;;; some are not active.
(DEFVAR WINDOW-RESOURCE-NAMES NIL
  "List of names of all DEFWINDOW-RESOURCEs.")

;;; The following are checker functions for window resources.  The idea
;;; is that a checker function is called with a particular window
;;; resource instance, and it will return T if that window resource
;;; instance is available for use.
(DEFUN CHECK-UNLOCKED-WINDOW-RESOURCE    (IGNORE WINDOW IN-USE-P &REST IGNORE)
  (AND (NOT IN-USE-P)
       (SHEET-CAN-GET-LOCK WINDOW)))

(DEFUN CHECK-DEEXPOSED-WINDOW-RESOURCE   (IGNORE WINDOW IN-USE-P &REST IGNORE)
  (AND (NOT IN-USE-P)
       (or (not (mac-system-p))
	   (EQ tv:default-screen (tv:sheet-get-screen window)))
       (NOT (SHEET-EXPOSED-P WINDOW))
       (SHEET-CAN-GET-LOCK   WINDOW)))

(DEFUN CHECK-DEACTIVATED-WINDOW-RESOURCE (IGNORE WINDOW IN-USE-P &REST IGNORE)
  ;;;check the resource to insure it has the right attributes for the screen
  ;;;it is going to be displayed on.
  (AND (NOT IN-USE-P)
       (EQ tv:default-screen (tv:sheet-get-screen window))
       (NOT (MEMBER WINDOW (SHEET-INFERIORS (SHEET-SUPERIOR WINDOW)) :TEST #'EQ))
       (SHEET-CAN-GET-LOCK WINDOW)))

;;; Defintions for screen management
(DEFMACRO RECT-SOURCE (R) `(FIRST  ,R))
(DEFMACRO RECT-LEFT   (R) `(SECOND ,R))
(DEFMACRO RECT-TOP    (R) `(THIRD  ,R))
(DEFMACRO RECT-RIGHT  (R) `(FOURTH ,R))
(DEFMACRO RECT-BOTTOM (R) `(FIFTH  ,R))
(DEFMACRO RECT-WITHIN-RECT-P (R1 R2)
  "R1 within R2."
  `(AND (>= (RECT-LEFT   ,R1) (RECT-LEFT   ,R2))
	(<= (RECT-RIGHT  ,R1) (RECT-RIGHT  ,R2))
	(>= (RECT-TOP    ,R1) (RECT-TOP    ,R2))
	(<= (RECT-BOTTOM ,R1) (RECT-BOTTOM ,R2))))

(DEFMACRO RECT-NOT-OVERLAP-RECT-P (R1 R2)
  `(OR (<= (RECT-RIGHT  ,R2) (RECT-LEFT ,R1))
       (<= (RECT-RIGHT  ,R1) (RECT-LEFT ,R2))
       (<= (RECT-BOTTOM ,R2) (RECT-TOP  ,R1))
       (<= (RECT-BOTTOM ,R1) (RECT-TOP  ,R2))))

(DEFVAR SCREEN-MANAGER-QUEUE NIL
  "List of operations to be performed eventually by the screen
manager.  Each operation involves filling a screen rectangle from
some sheet.  See the file SYS:WINDOW;SCRMAN.")
(DEFVAR SCREEN-MANAGER-TOP-LEVEL T)

(DEFMACRO DELAYING-SCREEN-MANAGEMENT (&BODY BODY)
  "Collect any screen manages that get queued during its body,
and force them to happen later.  This code is unwind-protected so
that all pending manages get done, as they are necessary to have the
screen look correct.  The code tries to remove duplicate screen
manages when it finally does them, and after it finishes all the
managing does an autoexpose on all superiors that it hacked."
  `(LET ((.QUEUE-LEFT. T))
     (UNWIND-PROTECT
	 (LET ((OLD-SCREEN-MANAGER-TOP-LEVEL SCREEN-MANAGER-TOP-LEVEL))
	   (WHEN SCREEN-MANAGER-TOP-LEVEL
	     (SETQ SCREEN-MANAGER-QUEUE NIL))
	   (MULTIPLE-VALUE-PROG1
	     (UNWIND-PROTECT
		 (LET ((INHIBIT-SCREEN-MANAGEMENT T)
		       (SCREEN-MANAGER-TOP-LEVEL NIL))
		   (PROGN . ,BODY))
	       (SCREEN-MANAGE-DELAYING-SCREEN-MANAGEMENT-INTERNAL)
	       (SETQ .QUEUE-LEFT. SCREEN-MANAGER-QUEUE))
	     (SETQ SCREEN-MANAGER-TOP-LEVEL OLD-SCREEN-MANAGER-TOP-LEVEL)))
       (AND (NEQ .QUEUE-LEFT. T)
	    SCREEN-MANAGER-TOP-LEVEL
	    (DOLIST (E .QUEUE-LEFT.)
	      (APPLY #'SCREEN-MANAGE-QUEUE (FIRST (FIRST E)) (CDR E)))))))

(DEFMACRO WITHOUT-SCREEN-MANAGEMENT (&BODY BODY)
  "This causes any screen manages that get queued during its
body to get flushed if the body exits normally.  Abnormal exit will
cause the screen manages to remain on the queue so that they do get
done.  This is useful in circumstances when you know you'll be doing
screen management on the same stuff right away."
  `(LET ((.FLAG. NIL))
     (UNWIND-PROTECT
       (LET ((SCREEN-MANAGER-QUEUE NIL)
	     (SCREEN-MANAGER-TOP-LEVEL NIL))
	 (UNWIND-PROTECT
	   (LET ((INHIBIT-SCREEN-MANAGEMENT T))
	     (PROG1 ,@BODY
		    ;; Body completed successfully, flush any screen
		    ;; manages that got queued.
		    (SETQ SCREEN-MANAGER-QUEUE NIL)))
	   (SETQ .FLAG. SCREEN-MANAGER-QUEUE)))
       (DOLIST (E .FLAG.)
	 ;; Requeue entries
	 (APPLY #'SCREEN-MANAGE-QUEUE (FIRST (FIRST E)) (CDR E))))))

;;; Macros to help out the squeaking furry things.

(defvar *process-owning-mouse* nil)

(DEFMACRO WITH-MOUSE-GRABBED (&BODY BODY)
  "Tell the mouse process to just track the mouse while BODY is
executing.  The mouse process no longer sends windows messages about
the mouse.  It does update TV:MOUSE-X and TV:MOUSE-Y.  BODY can wait
for changes in the tracked mouse position with TV:MOUSE-WAIT.  BODY
must setthe mouse blinker right away, for example by
 (MOUSE-STANDARD-BLINKER)."
  `(progn
     (let ((inhibit-scheduling-flag t))
       (cond (window-owning-mouse
	      (when (and (not (null *process-owning-mouse*))
			 (neq *process-owning-mouse* current-process))
		(setq inhibit-scheduling-flag nil)
		(process-wait "Wait for ungrab"
			      #'(lambda (process)
				  (unless window-owning-mouse
				    (setf window-owning-mouse :being-grabbed
					  *process-owning-mouse* process)))
			      current-process)))
	     (t (setf window-owning-mouse :being-grabbed
		      *process-owning-mouse* current-process))))
     (LET ((.OLD.VALUE. (if (eq WINDOW-OWNING-MOUSE :being-grabbed) nil window-owning-mouse)))
       (LET-GLOBALLY ((WHO-LINE-MOUSE-GRABBED-DOCUMENTATION NIL))
	 (UNWIND-PROTECT
	     (PROGN
	       (WITH-MOUSE-GRABBED-INTERNAL T)
	       . ,BODY)
	   (without-interrupts
	     (SETQ WINDOW-OWNING-MOUSE .OLD.VALUE.)
	     (unless window-owning-mouse (setf *process-owning-mouse* nil))
	     (SETQ MOUSE-RECONSIDER T)))))))


(DEFMACRO WITH-MOUSE-GRABBED-ON-SHEET ((SHEET) &BODY BODY)
  "This is a special version of WITH-MOUSE-GRABBED that allows you
to bind TV:MOUSE-SHEET to a specified SHEET.
SHEET defaults to SELF."
  (LET ((OLD-MOUSE-SHEET-SYMBOL (GENSYM)))
    `(LET ((,OLD-MOUSE-SHEET-SYMBOL MOUSE-SHEET))
       (UNWIND-PROTECT
	   (WITH-MOUSE-GRABBED
	     (MOUSE-SET-SHEET ,(OR SHEET 'SELF))	;SHEET defaults to SELF
	     ,@BODY)
	 (MOUSE-SET-SHEET ,OLD-MOUSE-SHEET-SYMBOL)))))


(DEFMACRO WITH-MOUSE-USURPED (&BODY BODY)
  "Tell mouse process to do absolutely nothing while BODY is
executed. BODY can track the mouse using TV:MOUSE-INPUT."
  `(LET ((.OLD.VALUE. WINDOW-OWNING-MOUSE))
     (LET-GLOBALLY ((WHO-LINE-MOUSE-GRABBED-DOCUMENTATION NIL))
       (UNWIND-PROTECT
	 (PROGN
	   (WITH-MOUSE-GRABBED-INTERNAL 'STOP)
	   . ,BODY)
	 (SETQ WINDOW-OWNING-MOUSE .OLD.VALUE.)
	 (SETQ MOUSE-RECONSIDER T)))))

(DEFUN with-mouse-grabbed-internal
       (rodent-window &aux (inhibit-scheduling-flag t))
  "Tell the mouse process to switch MODES and wait for it to do so."
  (SETQ window-owning-mouse rodent-window)
  (COND
    ((NEQ rodent-window mouse-window)
     (SETQ mouse-reconsider t inhibit-scheduling-flag ())
     ;; Screen exposure at boot-up usurps the mouse before the mouse-process starts
     ;; (or is even bound - KJF 07/18/88)
     ;; In this case, don't sit around waiting for a non-existant mouse-process.  CJJ 04/21/88.
     (IF (AND (BOUNDP 'mouse-process)
	      (TYPEP mouse-process 'process)
	      (SEND mouse-process :active-p)
	      (NOT (EQ (PROCESS-WAIT-FUNCTION mouse-process) 'si:flushed-process)))
	 (PROCESS-WAIT "Grab Mouse"
		       #'(lambda (rodent-window)
			   (AND (NULL mouse-reconsider)
				(EQ mouse-window rodent-window)))
		       rodent-window)
	 ;;ELSE...
	 (SETF mouse-reconsider nil
	       mouse-window rodent-window)))))

;;; Server structure used by WHOLIN and PEEK.
(DEFSTRUCT (SERVER-DESC (:TYPE :LIST) (:CONC-NAME SERVER-DESC-)
  (:ALTERANT ALTER-SERVER-DESC) (:PREDICATE NIL) (:COPIER NIL))
  CONNECTION
  HOST-NAME
  CONTACT-NAME
  PROCESS
  FUNCTION
  ARGS)

;; Used by the screen-manager.
(DEFSUBST RECTANGLE-NOT-INTERSECTION (RPRIME RAUX)
  "Return a set of rectangles which consists of all the area in RAUX
that is not also in RPRIME.  The set is guaranteed to be canonical."
  (LET ((SET (%RECTANGLE-NOT-INTERSECTION RPRIME RAUX)))
    (COND
      ((EQ SET RAUX)
       ;; No intersection at all, just return RAUX
       (CONS RAUX ()))
      (T SET))))

(PROCLAIM '(INLINE SAFE-CHAR=))
;;; Note that this function only handles 2 arguments.  The
;;; general case handles an arbitrary number of arguments.
(DEFUN SAFE-CHAR= (CHAR1 CHAR2)
  "Safe CHAR= which does not assume that its arguments are character objects."
  (IF (AND (OR (CHARACTERP CHAR1) (typep CHAR1 'FIXNUM))
	   (OR (CHARACTERP CHAR2) (typep CHAR2 'FIXNUM)))
      (CHAR= CHAR1 CHAR2)
      ;;ELSE
      (EQUAL CHAR1 CHAR2)))

;;; Graying stuff

(DEFUN MAKE-GRAY (HEIGHT WIDTH &REST ROWS &AUX GRAY RWIDTH PAT)
  "Return a bitblt array containing a specified gray pattern.
The pattern's size is HEIGHT by WIDTH, and ROWS is a list of
numbers, each of which describes one row of the pattern, one octal
digit per pixel, left to right.  WIDTH cannot be greater than 8.  The
array's first dimension will be some multiple of WIDTH that is suitable
for a BITBLT array."
  (CHECK-ARG HEIGHT (= HEIGHT (LENGTH ROWS)) "equal to number of rows")
  (CHECK-ARG WIDTH (< WIDTH 32) "less than or equal to 31")
  (DO ((L ROWS (CDR L)))			;CONVERT OCTAL BINARY TO BINARY
      ((NULL L)
       NIL)
    (RPLACA L
	    (DO ((W (CAR L) (LSH W -3))
		 (MASK 1 (LSH MASK 1))
		 (RESULT 0))
		((ZEROP W)
		 RESULT)
	      (AND (LOGTEST 1 W)
		   (SETQ RESULT (LOGIOR RESULT MASK))))))
  (DOTIMES (I WIDTH)
    (AND (ZEROP (REM (* 32 (1+ I)) WIDTH))
	 (RETURN (SETQ RWIDTH (* 32 (1+ I))))))
  (SETQ GRAY (MAKE-ARRAY `(,HEIGHT ,RWIDTH) :ELEMENT-TYPE 'BIT))
  (DOTIMES (H HEIGHT)
    ;; Replicate PAT into GRAY starting with the high bits of PAT and
    ;; working to the lo bits.  Repeat this until row H is full.
    (SETQ PAT (NTH H ROWS))
    (DOTIMES (W RWIDTH)
      ;; When we put bits into an BIT array only the low order bit
      ;; gets saved.  The higher order bits are thrown away.
      (SETF (AREF GRAY H W) (LSH PAT (- (1+ (REM W WIDTH)) WIDTH)))))
  GRAY)

;;; Some common grays.
;;; These are used to draw gray onto the screen. They are initialized in
;;; this strange manner to make them work properly with BITBLT -- the
;;; width must be a multiple of 32.  The way to think of these grays is
;;; as a 2 dimensional array with enough bits on to corresponds to the
;;; proper gray level.  When the pattern is copied onto the screen, it
;;; should be such that the underlying gray pattern is not easy to see
;;; (i.e. no streaking and no splotches).  All of the gray patterns
;;; are shown below to help visualize how they are implemented.
;;;
;;;         88%              75%              66%              50%
;;;    .-----------.    .-----------.     .--------.         .-----.
;;;    |  |XX|XX|XX|    |  |XX|XX|XX|     |  |XX|XX|         |  |XX|
;;;    |--+--+--+--|    |--+--+--+--|     |--+--+--|         |--+--|
;;;    |XX|XX|XX|XX|    |XX|XX|  |XX|     |XX|  |XX|         |XX|  |
;;;    |--+--+--+--|    |--+--+--+--|     |--+--+--|         `-----'
;;;    |XX|XX|  |XX|    |XX|  |XX|XX|     |XX|XX|  |
;;;    |--+--+--+--|    |--+--+--+--|     `--------'
;;;    |XX|XX|XX|XX|    |XX|XX|XX|  |
;;;    `-----------'    `-----------'
;;;
;;;         33%              25%              12%
;;;     .--------.      .-----------.    .-----------.
;;;     |XX|  |  |      |XX|  |  |  |    |XX|  |  |  |
;;;     |--+--+--|      |--+--+--+--|    |--+--+--+--|
;;;     |  |XX|XX|      |  |  |XX|  |    |  |  |  |  |
;;;     |--+--+--|      |--+--+--+--|    |--+--+--+--|
;;;     |  |  |XX|      |  |XX|  |  |    |  |  |XX|  |
;;;     `--------'      |--+--+--+--|    |--+--+--+--|
;;;                     |  |  |  |XX|    |  |  |  |  |
;;;                     `-----------'    `-----------'
(DEFVAR 100%-BLACK (MAKE-GRAY 2 2 #o11   #o11))
(DEFVAR 88%-GRAY   (MAKE-GRAY 4 4 #o0111 #o1111 #o1101 #o1111))
(DEFVAR 75%-GRAY   (MAKE-GRAY 4 4 #o0111 #o1101 #o1011 #o1110))
(DEFVAR 66%-GRAY   (MAKE-GRAY 3 3 #o011  #o101 #o110))
(DEFVAR 50%-GRAY   (MAKE-GRAY 2 2 #o01   #o10))
(DEFVAR 33%-GRAY   (MAKE-GRAY 3 3 #o100  #o010 #o001))
(DEFVAR 25%-GRAY   (MAKE-GRAY 4 4 #o1000 #o0010 #o0100 #o0001))
(DEFVAR HES-GRAY   (MAKE-GRAY 4 4 #o1000 #o0000 #o0010 #o0000))
(DEFVAR 12%-GRAY   (MAKE-GRAY 4 4 #o1000 #o0000 #o0010 #o0000))
(DEFVAR 100%-WHITE (MAKE-GRAY 2 2 #o00   #o00))


(DEFMACRO with-clipping-rectangle ((left top right bottom) &BODY body)
  "Execute BODY with the clipping rectangle bound to left, top, right, and bottom which should be integers.
 Microcode will not draw outside of the edges specified by the clipping rectangle."
  `(if (and (typep ,left 'fixnum) (typep ,top 'fixnum) (typep ,right 'fixnum) (typep ,bottom 'fixnum))
     (let
       ((sys:*clipping-rectangle-left-edge*   ,left)
	(sys:*clipping-rectangle-top-edge*    ,top)
	(sys:*clipping-rectangle-right-edge*  ,right)
	(sys:*clipping-rectangle-bottom-edge* ,bottom))
       . ,body)
     (ferror nil "One of the arguments to w:with-clipping-rectangle was not an integer.")))

;;; often used when making sheet bit arrays.
(PROCLAIM '(INLINE round-up-to-32))
(defun round-up-to-32 (fixnum)
  "Return smallest fixnum greater than or equal to FIXNUM that is evenly divisible by 32."
  (LOGAND #o-40 (+ #o37 fixnum)))

;; these two functions are in the sys package because they used to be in microcode.

;;; Drawing a line is the same as drawing a triangle with collinear points.
(defun sys:%draw-line (x1 y1 x2 y2 alu draw-end-point window-or-array)
  "Draw a line from X1 Y1 to X2 Y2 using ALU on WINDOW-OR-ARRAY.  DRAW-END-POINT means draw X2 Y2."
  ;; Pass x2 y2 as the second AND third points to %draw-shaded-triangle so that the
  ;; second triangle edge becomes a POINT.  Draw-end-point should then be passed as the
  ;; draw-second-edge argument to %draw-shaded-triangle.  - GRH 3/23/87
  (IF (mac-window-p window-or-array)
      (send-draw-line x1 y1 x2 y2 alu draw-end-point window-or-array)
    ;; else...
    (%DRAW-SHADED-TRIANGLE x1 y1 x2 y2 x2 y2 alu t draw-end-point t nil window-or-array))
  )

(DEFUN sys:%draw-char (font char x y alu window-or-array)
   "Draw CHAR from FONT at X, Y with ALU on WINDOW-OR-ARRAY.  Calls %draw-character with
 character's raster-width.  If this fails the character's real width is used.  This is so that the extra
 pixels in a character's image beyond its width (as in italic fonts) don't get clipped except at the
 edge of a window.  Returns t if the character is successfully drawn, else nil."
  (IF (mac-window-p window-or-array)
      (send-draw-char font char x y alu window-or-array)
    ;; else...
    (OR (%draw-character font char nil x y alu window-or-array)
	(%draw-character font char
			 (LET ((fwt (font-char-width-table font)))
			   (IF fwt
			       (AREF fwt char)
			     (font-char-width font)))
			 x y alu window-or-array))))

(DEFUN DRAW-CHAR-INTERNAL-FIT (FONT CH X Y ALU WINDOW FIT)
  "Draw character from font with font indexing table FIT.
 Returns t if the character is successfully drawn, else nil."
  (DO ((CH (AREF FIT CH) (1+ CH))
       (WIDTH (FONT-RASTER-WIDTH FONT))
       (LIM (AREF FIT (1+ CH)))
       (X X (+ X WIDTH )))
      ((>= CH LIM) t)
    (%DRAW-CHARACTER FONT CH WIDTH X Y ALU WINDOW)))


(PROCLAIM '(INLINE draw-char-internal))
(DEFUN DRAW-CHAR-INTERNAL (FONT CH X Y ALU WINDOW FIT &optional color)
  "Similar to %draw-char but handles fonts with index tables
 for characters wider than 32 pixels.  Returns t if the character
 is successfully drawn, else nil."
  (IF (mac-window-p window)
      (send-draw-char font ch x y alu window)
      ;; Only do prepare-color if a color is specified (for performance reasons) and if WINDOW
      ;; arg is a sheet and not an array.  Fixes SPR #8202.  07/11/88 KJF.
      (IF (AND color (TYPEP window 'sheet))
	  (prepare-color (window color)
	    (IF FIT
		(draw-char-internal-fit FONT CH X Y ALU WINDOW fit)
		(%DRAW-CHAR FONT CH X Y ALU WINDOW)))
	  (IF FIT
	      (draw-char-internal-fit FONT CH X Y ALU WINDOW fit)
	      (%DRAW-CHAR FONT CH X Y ALU WINDOW)))))



;;; Define the obsolete miscops in lisp to call the new miscops.

(COMPILER:MAKE-OBSOLETE SYS:%DRAW-FILLED-TRIANGLE "use SYS:%DRAW-SHADED-triangle instead")
(defun sys:%draw-filled-triangle (x1 y1 x2 y2 x3 y3 left top right bottom
				   alu draw-first-edge draw-second-edge draw-third-edge
				   shade window-or-array)
   left top right bottom	;; ignore
   (%DRAW-SHADED-TRIANGLE x1 y1 x2 y2 x3 y3
			  alu draw-first-edge draw-second-edge draw-third-edge
			  shade window-or-array))

(COMPILER:MAKE-OBSOLETE SYS:%DRAW-FILLED-RASTER-LINE "use SYS:%DRAW-SHADED-raster-line instead")
(defun sys:%draw-filled-raster-line (x1 x2 y left top right bottom
				      alu draw-last-point shade window-or-array)
   left top right bottom	;; ignore
   (%DRAW-SHADED-RASTER-LINE x1 x2 y alu draw-last-point shade window-or-array))

;; does this symbol still exist in the sys package???
(COMPILER:MAKE-OBSOLETE SYS:%DRAW-TRIANGLE "use SYS:%DRAW-SHADED-triangle instead")
(defun sys:%draw-triangle (x1 y1 x2 y2 x3 y3 alu window-or-array)
   (%DRAW-SHADED-TRIANGLE x1 y1 x2 y2 x3 y3 alu t t t nil window-or-array))

;;; Bind this non-nil to skip compute-geometry and W:compute-geometry
(DEFVAR *delay-compute-geometry* nil)

(DEFMACRO delaying-compute-geometry (&body body)
  `(LET ((*delay-compute-geometry* t))
     ,@body))

;; may 01/27/89
;;; Added by KJF on 08/19/88 for CJJ during addition of Multiple Monitor (MMON) support.
(DEFMACRO with-screens-previously-selected-windows
	  ((sheet) &body body)
  "Forces all accesses to PREVIOUSLY-SELECTED-WINDOWS in BODY to reference SHEET's screen's
SCREENS-PREVIOUSLY-SELECTED-WINDOWS instance variable.
When SHEET's screen is DEFAULT-SCREEN, all accesses to PREVIOUSLY-SELECTED-WINDOWS in BODY
also reference the global PREVIOUSLY-SELECTED-WINDOWS
because DEFAULT-SCREEN's SCREENS-PREVIOUSLY-SELECTED-WINDOWS
instance variable points to the same array pointed to by the global variable."
  (ONCE-ONLY (sheet)
    (LET ((screen (GENSYM)))
      `(LET (,screen)
	 (LET-IF (AND (TYPEP ,sheet 'tv:sheet)
		      (SETF ,screen (tv:sheet-get-screen ,sheet))
		      (tv:explorer-screen-p ,screen))
		 ((tv:previously-selected-windows
		    (tv:screen-screens-previously-selected-windows ,screen)))
	   ,@body)))))
